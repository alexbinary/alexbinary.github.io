<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-05-17T09:54:28-05:00</updated><id>/feed.xml</id><title type="html">Making something great</title><subtitle> Alexandre Bintz - maker, coder, thinker #programming #3dprinting #electronics #woodworking #LEGO #photography </subtitle><entry><title type="html">(fr) Photos</title><link href="/2025/04/04/photos_fr.html" rel="alternate" type="text/html" title="(fr) Photos" /><published>2025-04-04T02:52:01-05:00</published><updated>2025-04-04T02:52:01-05:00</updated><id>/2025/04/04/photos_fr</id><content type="html" xml:base="/2025/04/04/photos_fr.html"><![CDATA[<p>Voici quelques photos que j’ai prises. Plus sur ma page <a href="https://www.flickr.com/photos/189385048@N05/">my Flickr</a>.</p>

<p><a href="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg"><img src="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg"><img src="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg"><img src="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg"><img src="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg"><img src="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg"><img src="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg"><img src="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg" alt="" /></a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Voici quelques photos que j’ai prises. Plus sur ma page my Flickr.]]></summary></entry><entry><title type="html">Photos</title><link href="/2025/04/04/photos_en.html" rel="alternate" type="text/html" title="Photos" /><published>2025-04-04T02:52:01-05:00</published><updated>2025-04-04T02:52:01-05:00</updated><id>/2025/04/04/photos_en</id><content type="html" xml:base="/2025/04/04/photos_en.html"><![CDATA[<p>Here are some pictures I took. You can see more on <a href="https://www.flickr.com/photos/189385048@N05/">my Flickr</a>.</p>

<p><a href="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg"><img src="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg"><img src="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg"><img src="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg"><img src="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg"><img src="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg"><img src="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg"><img src="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg" alt="" /></a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Here are some pictures I took. You can see more on my Flickr.]]></summary></entry><entry><title type="html">(fr) Projet: tiroirs connectés</title><link href="/2025/03/28/smart-drawers_fr.html" rel="alternate" type="text/html" title="(fr) Projet: tiroirs connectés" /><published>2025-03-28T03:17:53-05:00</published><updated>2025-03-28T03:17:53-05:00</updated><id>/2025/03/28/smart-drawers_fr</id><content type="html" xml:base="/2025/03/28/smart-drawers_fr.html"><![CDATA[<p><img src="/assets/2025-03-28-smart-drawers/0.jpg" alt="" style="padding-bottom: 1rem" /></p>

<p>Dans cet article je présente l’idée générale et le choix des composants.
Plus tard je présenterai les avancées du projet.</p>

<h2 id="introduction">Introduction</h2>

<p>Dans un article précédent, j’ai présenté la solution que j’ai conçue et fabriquée pour ranger les pièces de LEGO que je vends sur ma boutique en ligne.
Je cherche toujours à optimiser le travail de gestion du stock,
que ce soit lorsque je prélève des pièces pour la préparation de commande (picking)
ou lorsque je rentre de nouvelles pièces.
Parallèlement, ces derniers temps j’avais envie de me remettre à l’électronique.</p>

<p>La première idée qui m’est venue consistait à implémenter un système d’indicateurs lumineux
pour mettre en valeur le tiroir dans lequel se trouvent les pièces recherchées.
Mais intégrer les composants sur un tiroir qui doit rester mobile ma paraissait complexe.
Par ailleurs, je pense qu’une seule LED n’aurait pas été assez voyante.
Il aurait peut-être fallu mettre toute une bande de LED, ou ajouter un bip.</p>

<p>L’idée suivante était l’ouverture automatique du tiroir.
Une mécanisation complète me paraissait complexe et couteuse,
et aurait probablement occupé un espace précieux.
Je suis donc plutôt parti sur juste une impulsion, un peu comme les tiroirs de caisses enregistreuses.
Le mouvement et le bruit sont efficaces pour attirer l’attention sur le tiroir.
Au début j’avais pensé à un système qui placerait les tiroirs sur ressorts,
et un système de vérouillage mécanique qui pourrait être libéré électroniquement.
Ça me semblait complexe à mettre au point et intégrer,
et en plus ça aurait empêché l’ouverture manuelle, ce qui n’est pas ce que je voulais.</p>

<p>Et puis j’ai eu une idée toute simple :
utiliser des électroaimants pour repousser des aimants permanants
attachés sur les tiroirs.
Le tout pourrait être intégré dans le fond du meuble, sans prendre beaucoup de place,
et n’empêcherait pas l’ouverture manuelle des tiroirs.
C’est une solution extrêmement simple et élégante !</p>

<h3 id="architecture-générale">Architecture générale</h3>

<p>Le système serait piloté par mon logiciel de picking qui commanderait l’ouverture du tiroir approprié au moment où j’ai besoin de prélever les pièces.</p>

<p>Premièrement, il faut une carte de contrôle pour orchestrer les aimants et communiquer avec le PC.
Le plus simple est sûrement un Rasperry Pi, avec lequel j’ai déjà une bonne expérience.
Mais je voulais apprendre quelque chose de nouveau.
J’ai beaucoup entendu parlé d’Arduino mais je n’ai encore jamais testé par moi-même.
C’est l’occasion d’y remédier.
Par ailleurs, j’ai envie de travailler à plus bas niveau, notamment au niveau de la communication sans fil.
Sur le plan logiciel, travailler sur un Rasperry Pi revient à travailler sur un PC Linux, je n’ai pas envie de ça.</p>

<p>Pour la liaison sans fil avec le PC,
j’opte pour Bluetooth, qui me parait une solution simple en plus d’être très répandue.</p>

<p>Les aimants seront montés dans le fond du meuble, et câblés jusqu’à la carte et le reste du circuit
qui seront intégrés quelque part sur l’arrière du meuble.</p>

<h3 id="recherche-des-composants">Recherche des composants</h3>

<p>Comme dans tout projet qui implique beaucoup de nouveautés,
je commence par viser quelque chose qui soit le plus simple possible.
Le but est de réduire au minimum les sources de complications
pour obtenir quelque chose qui fonctionne.
Ça permet déjà de valider le principe de base, et de prendre en main les choses.
Ensuite on peut itérer pour améliorer et aller vers quelque chose de plus abouti.</p>

<p>J’ai commencé mes recherches sur Amazon par habitude,
mais je suis vite passé sur AliExpress car les prix sont largement inférieurs.
Le projet est une expérimentation, je cherche avant tout à apprendre et tester des idées.
Des composants d’entrée de gamme suffisent.
Certains resteront peut-être inutilisés, d’autres peuvent être endomagés,
inutile donc d’investir dans de la qualité.</p>

<p>Si le projet est concluant, je pourrais “mettre au propre”
en affinant le choix des composants pour l’efficacité et la durabilité.</p>

<p>Dans la même logique, quand c’est pertient je parts sur des composants de prototypage
plutôt que des composants finaux.
La mise au propre remplacera ces composants par des version finales
et libérera les composants de prototypage pour de futurs projets.</p>

<h2 id="carte-de-contrôle">Carte de contrôle</h2>

<p>J’opte pour l’Arduino UNO R4 Wifi.
C’est le modèle classique, équipé de connectivité sans fil Bluetooth et Wi-Fi.
Le Wi-Fi est intéressant, ça laisse l’option de l’utiliser pour la liaison PC
en complément ou en remplacement du Bluetooth.</p>

<p><img src="https://store.arduino.cc/cdn/shop/files/ABX00087_01.iso_65d9153b-9fe3-4d51-8f0a-750fcca31c5e_509x382.jpg" alt="Arduino UNO R4 Wifi sur l'Arduino store" /></p>

<p><a href="https://store.arduino.cc/en-fr/products/uno-r4-wifi">Arduino UNO R4 Wifi sur l’Arduino store</a></p>

<h2 id="electroaimants">Electroaimants</h2>

<p>Avant toute chose il faut avoir une idée de la force nécessaire pour ouvrir un tiroir.
L’idéal aurait été d’utiliser un dynamomètre, mais je n’en ai pas.
Après quelques réflexions, j’ai attaché un fil à une poignée,
tendu le fil sur la table devant le tiroir, et suspendu divers objets au fil
jusqu’à ce que le tiroir s’ouvre sous l’effet de la gravité agissant sur l’objet et via le fil.
En pesant ensuite l’objet, j’ai une idée de la force nécessaire.
En l’occurence un objet d’à peine 100g a suffit.</p>

<p>Il existe apparamment un modèle standard d’électroaimants,
qui existe en différentes tailles et forces.
Les forces classiques sont de l’ordre du kilogramme, c’est largement suffisant dans mon cas.
Les aimants sont alimentés en 12 ou 24V continu,
et possèdent un filetage à l’arrière pour la fixation.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sb93cfd04f3e84579b00a24a26e19ce7fg.jpg_960x960q75.jpg_.avif" alt="Electroaimants sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005712625900.html">Electroaimants sur AliExpress</a></p>

<h2 id="pilotage-des-aimants">Pilotage des aimants</h2>

<p>Une fois les aimants trouvé, reste à voir comment les piloter avec l’Arduino,
sachant que celle-ci fonctionne en 5V.
Une recherche me donne
<a href="https://deepbluembedded.com/arduino-electromagnet-control-circuit-code-example/">ce tuto</a>
qui fait exactement ce que je cherche à faire.</p>

<h3 id="transistor">Transistor</h3>

<p>Le principe est d’utiliser un transistor pour faire comme un interrupteur
qui ouvre ou ferme le circuit d’alimentation de l’aimant.
Le tuto utilise un transistor bipolaire de type NPN, référence TIP120.
C’est une référence courante, je n’ai pas de mal à la trouver.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S39a89f0f8b0246e38bbc624e360ee1f19.jpg_960x960q75.jpg_.avif" alt="Transistor TIP120 sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005007657188686.html">Transistor TIP120 sur AliExpress</a></p>

<h3 id="résistances">Résistances</h3>

<p>Il faut prévoir une résistance pour la commande du transistor.
La valeur de la résistance dépend des caractéristiques du transistor et de l’aimant.
Dans mon cas je n’ai pas beaucoup d’infos sur l’électroaimant que j’ai repéré.
Pour fixer les idées en attendant mieux, je me base sur la résistance utilisée dans le tuto.
Une fois l’aimant en main je pourrais mesurer les données dont j’ai besoin.
En attendant, pour avoir de quoi avancer,
je trouve sur AliExpress un lot de 300 résistances de différentes valeurs pour moins de 2€.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S5afe69af1b43434f91b42a4f37a3b4c0Q.jpg_960x960q75.jpg_.avif" alt="Résitances sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005855324735.html">Résitances sur AliExpress</a></p>

<h3 id="diode">Diode</h3>

<p>Enfin, l’électroaimant étant un solénoïde, il faut prévoir une <em>diode de roue libre</em>.
Un solénoïde s’oppose aux changements brusques de courant,
et a besoin de pouvoir dissiper son énergie lorsqu’on coupe son alimentation.
C’est le rôle de la diode de roue libre, qu’on monte en parallèle dans le sens opposé
et qui vient ainsi former un circuit secondaire dans lequel l’energie va pouvoir se dissiper
sans endommager le reste du cricuit principal.
La diode doit être dimensionnée pour supporter la tension et le courant.
La référence classique est 1N4001 qui supporte 1A et 50V, c’est largement suffisant.
Je trouve cette référence sans problème sur AliExpress.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S372589c6b14d453290d0a126206a4b6c3.jpg_960x960q75.jpg_.avif" alt="Diodes 1N4001 sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005001552094086.html">Diodes 1N4001 sur AliExpress</a></p>

<h2 id="piloter-de-nombreux-aimants">Piloter de nombreux aimants</h2>

<p>J’ai une trentaine de tiroirs en tout, et j’envisage de mettre au moins deux aimants par tiroir.
L’Arduino n’ayant qu’une dizaine de ports de sortie, il faut une solution pour ajouter plus de sorties.</p>

<p>En faisant des recherches, je tombe d’abord sur des circuits I2C qui ajoutent des GPIO complets,
c’est-à-dire des ports qui peuvent être configurés en entrée ou en sortie, avec ou sans pullup, etc.
Il y a 16 ports par puce, et il est possible de mettre jusqu’à 8 puces sur le meme bus I2C en jouant avec les adresses, pour un total de 128 pins.
C’est suffisant dans mon cas,
mais j’ai pour projet de toujours étendre ma capacité de rangement de LEGO,
et l’idée qu’il existe une limite au nombre d’aimants que je pourrais contrôler me gêne.</p>

<p>Je poursuis mes recherches et tombe sur les registres à décalage.
Ce sont des circuits très simples qui transforment une sortie série en parallèle.
Les pins ne fonctionnent qu’en sortie, ce qui n’est pas gênant dans mon cas.
Il est possible de les connecter les uns à la suite des autres (<em>daisy chaining</em>) sans limite théorique.
C’est parfait pour moi.
Le circuit classique est le 74HC595.
Je trouve la ref sans problème sur AliExpress.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sf000bea0f39043eeba141d929dc9001et.jpg_960x960q75.jpg_.avif" alt="Registre à décalage 74HC595 sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005004856540723.html">Registre à décalage 74HC595 sur AliExpress</a></p>

<h2 id="alimentation">Alimentation</h2>

<p>Dernier sujet majeur.
Il faut alimenter l’Arduino et les aimants.
L’Arduino fonctionne en 5V.
Les aimants doivent être alimentés en 12V.
Je pense que les aimants peuvent fonctionner en 5V. La force sera réduite mais ça peut être suffisant dans mon cas.
Cependant je préfère assurer le coup, quitte à ajuster ensuite.</p>

<p>La doc indique que l’Arduino peut prendre en entrée jusqu’à 24V grâce à un régulateur interne qui abaisse la tension à 5V.
Ça simplifie les choses puisque je peux donc utiliser une alimentation commune à 12V.</p>

<p>Même si ce serait tout à fait possible, je n’ai pas envie d’utiliser des piles ou des batterie,
rechargeable ou non.
Je cherche donc des alimentations à brancher sur secteur.</p>

<p>Je n’ai pas envie de m’embêter à trouver le bon connecteur.
L’Arduino possède un connecteur <em>barrel jack</em> classique,
mais la doc indique qu’il peut aussi être alimenté via des pins.
Je trouve plusieurs modèles d’alimentations fournies avec un adaptateur qui permet de connecter des fils.
Voilà qui sera plus simple.
En bonus, je trouve sur AliExpress un modèle réglable 3-24V.
Ça me permettra de régler la force des aimants,
et ce sera sûrement très utiles pour de futurs projets.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sd13fa0cffb734b0c834870c1d11174d9e.jpg_960x960q75.jpg_.avif" alt="Alimentation réglable 3-24V sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005638098269.html">Alimentation réglable 3-24V sur AliExpress</a></p>

<h2 id="aimants-permanents">Aimants permanents</h2>

<p>La dernière pièce du puzzle.
J’avais déjà acheté des aimants sur AliExpress pour un précédent projet,
et je sais qu’il en existe de toute sorte.
Je cherche des aimants qui soient à la fois assez plats pour ne pas prendre trop de place,
et assez larges pour maximiser l’interraction avec l’électroaimant.
Même si à terme j’envisage de les incruster dans le bois du tiroir,
dans un premier temps je pense simplement les fixer en surface.
Les meubles n’étant pas prévus pour accueillir des choses dans le fond,
plus les aimants sont compacts et mieux ce sera.
Je choisie une référence en 20x2mm avec adhésif fourni.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sfcbed82347c64b00a45a704217c2df3a7.jpg_960x960q75.jpg_.avif" alt="Aimants permanents sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005008096510030.html">Aimants permanents sur AliExpress</a></p>

<h2 id="matériel-divers">Matériel divers</h2>

<p>L’essentiel est là. Voyons maintenant si j’ai tout ce qu’il faut pour travailler efficacement.</p>

<p>J’ai encore en stock une breadboard quasi neuve.
Je vais commencer avec ça et voir déjà jusqu’où je peux aller.
Elle sera trop petite pour implémenter les circuits pour tous les tiroirs,
mais je pense pouvoir en faire déjà quelques uns pour valider le principe.
A terme je pourrais mettre au propre avec une carte à souder.
Je peux même envisager de concevoir et (faire) fabriquer un circuit imprimé sur mesure,
et faire un boitier en impression 3D.</p>

<p>J’ai aussi en stock quelques jumpers et quelques LEDs.
Ce sera bien pour expérimenter et prendre en main les composants.</p>

<p>Il faudra de la longueur de fil pour câbler les aimants des tiroirs jusqu’à la carte centrale.
Il faut 2 fils par aimants, il faut donc assez de longueur totale.
J’achète donc quelques petites bobines de fil.</p>

<p>Je commande aussi un multimètre premier prix.
Et voilà qui conclut la liste des composants.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S225cab5c7b6747cebf09016371dcfcceo.jpg_960x960q75.jpg_.avif" alt="Fil sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005007256968315.html">Fil sur AliExpress</a></p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S2a0fe6eaf6814accb0536a4c467851e75.jpg_960x960q75.jpg_.avif" alt="Multimètre sur AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005981700177.html">Multimètre sur AliExpress</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Project: Smart drawers</title><link href="/2025/03/28/smart-drawers_en.html" rel="alternate" type="text/html" title="Project: Smart drawers" /><published>2025-03-28T03:17:53-05:00</published><updated>2025-03-28T03:17:53-05:00</updated><id>/2025/03/28/smart-drawers_en</id><content type="html" xml:base="/2025/03/28/smart-drawers_en.html"><![CDATA[<p><img src="/assets/2025-03-28-smart-drawers/0.jpg" alt="" style="padding-bottom: 1rem" /></p>

<p>In this article, I present the general idea and the choice of components.
Later, I will share project updates.</p>

<h2 id="introduction">Introduction</h2>

<p>In a previous article, I introduced the solution I designed and built to organize the LEGO pieces I sell in my online store. I am always looking to optimize stock management, whether it’s when I pick pieces for order preparation or when I add new pieces. Meanwhile, I’ve recently wanted to get back into electronics.</p>

<p>The first idea that came to mind was to implement a system of light indicators to highlight the drawer containing the pieces to pick. However, integrating components into a drawer that needs to remain mobile seemed complex. Moreover, I think a single LED wouldn’t be noticeable enough. Perhaps a whole strip of LEDs would be needed, or I could add a beep.</p>

<p>The next idea was to automate the drawer opening. A complete mechanization seemed complex and costly, and it would likely take up valuable space. So I rather leaned towards a simple push mechanism, similar to cash register drawers. The movement and noise are effective for drawing attention to the drawer. Initially, I imagined spring loaded drawers with a mechanical locking system that could be released electronically. That seemed complicated to develop and integrate, and it would also prevent manual opening, which I did not want.</p>

<p>Then I had the very simple idea to use electromagnets to push permanent magnets attached to the drawers. This could be integrated into the back of the furniture without taking up much space and would not prevent manual opening of the drawers. It’s an extremely simple and elegant solution!</p>

<h3 id="general-architecture">General architecture</h3>

<p>The system would be controlled by my picking software, which would command the opening of the appropriate drawer at the moment I need to pick the pieces.</p>

<p>First, I need a control board to orchestrate the magnets and communicate with the PC. The simplest option is probably a Raspberry Pi, which I am already familiar with. However, I wanted to learn something new. I’ve heard a lot about Arduino but have never tested it myself. This is the perfect opportunity to remedy that. Furthermore, I want to work at a lower level, particularly regarding wireless communication. From a software perspective, working on a Raspberry Pi is akin to working on a Linux PC, and I don’t want that.</p>

<p>For wireless communication with the PC, I opt for Bluetooth, which seems to be a simple and widely used solution.</p>

<p>The magnets will be mounted at the back of the furniture and wired to the control board and the rest of the circuit, which will be integrated somewhere at the back of the furniture.</p>

<h3 id="component-research">Component research</h3>

<p>As with any project involving many new elements, I start by aiming for something as simple as possible. The goal is to minimize sources of complications to achieve something that works. This allows me to validate the basic principle and get a handle on things. I can then iterate and refine.</p>

<p>I started my research on Amazon out of habit, but I quickly switched to AliExpress because the prices are significantly lower. The project is an experiment; I’m primarily looking to learn and test ideas. Entry-level components are sufficient. Some may remain unused, and others may be damaged, so there’s no need to invest in quality.</p>

<p>If the project is successful, I can clean it up by refining the component choices for efficiency and durability.</p>

<p>In the same vein, when relevant, I lean towards prototyping components rather than final components. The cleanup will replace these components with final versions and free up the prototyping components for future projects.</p>

<h2 id="control-board">Control board</h2>

<p>I choose the Arduino UNO R4 Wi-Fi. It’s the classic model, equipped with wireless Bluetooth and Wi-Fi connectivity. The presence of Wi-Fi is interesting; it leaves the option to use it for PC communication in addition to or instead of Bluetooth.</p>

<p><img src="https://store.arduino.cc/cdn/shop/files/ABX00087_01.iso_65d9153b-9fe3-4d51-8f0a-750fcca31c5e_509x382.jpg" alt="Arduino UNO R4 Wi-Fi on the Arduino store" /></p>

<p><a href="https://store.arduino.cc/en-fr/products/uno-r4-wifi">Arduino UNO R4 Wi-Fi on the Arduino store</a></p>

<h2 id="electromagnets">Electromagnets</h2>

<p>First and foremost, I need to have an idea of the force required to open a drawer. Ideally, I would have used a dynamometer, but I don’t have one. After some thought, I attached a string to a handle, stretched the string across the table in front of the drawer, and suspended various objects from the string until the drawer opened under the weight of the object acting through the string. By weighing the object afterward, I get an idea of the necessary force. In this case, an object weighing barely 100g was enough.</p>

<p>There apparently exists a kind of standard model of electromagnets, which comes in various sizes and strengths. The typical forces are in the kilogram range, which is more than sufficient for my case. The magnets are powered by 12 or 24V DC and have a threaded back for mounting.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sb93cfd04f3e84579b00a24a26e19ce7fg.jpg_960x960q75.jpg_.avif" alt="Electromagnets on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005712625900.html">Electromagnets on AliExpress</a></p>

<h2 id="controlling-the-magnets">Controlling the magnets</h2>

<p>Once I found the magnets, I needed to figure out how to control them with the Arduino, knowing that it operates at 5V. A search leads me to <a href="https://deepbluembedded.com/arduino-electromagnet-control-circuit-code-example/">this tutorial</a> that does exactly what I’m trying to achieve.</p>

<h3 id="transistor">Transistor</h3>

<p>The principle is to use a transistor as a switch that opens or closes the power circuit for the magnet. The tutorial uses an NPN bipolar transistor, reference TIP120. It’s a common reference, and I have no trouble finding it.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S39a89f0f8b0246e38bbc624e360ee1f19.jpg_960x960q75.jpg_.avif" alt="Transistor TIP120 on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005007657188686.html">Transistor TIP120 on AliExpress</a></p>

<h3 id="resistors">Resistors</h3>

<p>A resistor is required to control the transistor. The value of the resistor depends on the characteristics of the transistor and the magnet. In my case, I don’t have much information about the electromagnet. For now, I’ll go with the resistor used in the tutorial. Once I have the magnet in hand, I can measure the data I need. In the meantime, to move forward, I find a pack of 300 resistors of different values on AliExpress for less than €2.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S5afe69af1b43434f91b42a4f37a3b4c0Q.jpg_960x960q75.jpg_.avif" alt="Resistors on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005855324735.html">Resistors on AliExpress</a></p>

<h3 id="diode">Diode</h3>

<p>Finally, since the electromagnet is a solenoid, a <em>flyback diode</em> is required. A solenoid opposes sudden changes in current and needs to dissipate its energy when its power supply is cut off. This is the role of the flyback diode, which is connected in parallel in the opposite direction and thus forms a secondary circuit where the energy can dissipate without damaging the rest of the main circuit. The diode must be rated to handle the voltage and current. The classic reference is 1N4001, which can handle 1A and 50V, which is more than sufficient. I find this reference easily on AliExpress.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S372589c6b14d453290d0a126206a4b6c3.jpg_960x960q75.jpg_.avif" alt="Diodes 1N4001 on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005001552094086.html">Diodes 1N4001 on AliExpress</a></p>

<h2 id="controlling-multiple-magnets">Controlling multiple magnets</h2>

<p>I have about thirty drawers in total and plan to install at least two magnets per drawer. Since the Arduino has only about ten output ports, I need a solution to add more outputs.</p>

<p>While researching, I first came across I2C circuits that add complete GPIOs, meaning ports that can be configured as input or output, with or without pull-up, etc. There are 16 ports per chip, and it’s possible to connect up to 8 chips on the same I2C bus by playing with the addresses for a total of 128 pins. This is sufficient for my case, but I always plan to expand my LEGO storage capacity, and the idea that there is a limit to the number of magnets I could control bothers me.</p>

<p>I continue my research and come across shift registers. These are very simple circuits that transform a serial output into parallel. The pins only function as outputs, which is not an issue in my case. They can be connected in series (<em>daisy chaining</em>) without any theoretical limit. This is perfect for me. The classic circuit is the 74HC595. I find the reference easily on AliExpress.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sf000bea0f39043eeba141d929dc9001et.jpg_960x960q75.jpg_.avif" alt="Shift register 74HC595 on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005004856540723.html">Shift register 74HC595 on AliExpress</a></p>

<h2 id="power-supply">Power supply</h2>

<p>The last major topic. I need to power the Arduino and the magnets. The Arduino operates at 5V. The magnets must be powered by 12V. I think the magnets can operate at 5V. The force will be reduced, but that may be sufficient in my case. However, I prefer to play it safe, even if it means adjusting later.</p>

<p>The documentation indicates that the Arduino can accept up to 24V input via an internal regulator that reduces the voltage to 5V. This simplifies things since I can use a common 12V power supply.</p>

<p>Even though it would be entirely possible, I do not want to use batteries.
So I look for wall bricks.</p>

<p>I don’t want to deal with finding the right connector. The Arduino has a classic <em>barrel jack</em> connector, but the documentation indicates that it can also be powered via pins. I find several power supply models provided with an adapter that allows wire connections. This will make things simpler. As a bonus, I find a model on AliExpress that is adjustable from 3-24V. This will allow me to adjust the magnet strength and will surely be very useful for future projects.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sd13fa0cffb734b0c834870c1d11174d9e.jpg_960x960q75.jpg_.avif" alt="Adjustable power supply 3-24V on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005638098269.html">Adjustable power supply 3-24V on AliExpress</a></p>

<h2 id="permanent-magnets">Permanent magnets</h2>

<p>The last piece of the puzzle. I had already bought magnets on AliExpress for a previous project, and I know that there are all sorts. I’m looking for magnets that are both flat enough not to take up too much space and wide enough to maximize interaction with the electromagnet. Even though I plan to embed them in the wood of the drawer in the long run, initially, I think I will simply attach them to the surface. Since the furniture is not designed to accommodate items in the back, the more compact the magnets are, the better. I choose a reference of 20x2mm with adhesive included.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/Sfcbed82347c64b00a45a704217c2df3a7.jpg_960x960q75.jpg_.avif" alt="Permanent magnets on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005008096510030.html">Permanent magnets on AliExpress</a></p>

<h2 id="miscellaneous">Miscellaneous</h2>

<p>The essentials are there. Now let’s see if I have everything needed to work efficiently.</p>

<p>I still have a nearly new breadboard in stock. I will start with that and see how far I can go. It will be too small to implement the circuits for all the drawers, but I think I can do a few to validate the principle. Ultimately, I could clean it up with a soldering board. I could even consider designing and having a custom printed circuit board made and creating a housing via 3D printing.</p>

<p>I also have a few jumpers and some LEDs in stock. These will be useful for experimenting and getting familiar with the components.</p>

<p>I will need wire to connect the magnets in the drawers to the central board. Two wires are needed per magnet, so I need enough total length. I will buy a few small spools of wire.</p>

<p>I will also order a basic multimeter. And that concludes the list of components.</p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S225cab5c7b6747cebf09016371dcfcceo.jpg_960x960q75.jpg_.avif" alt="Wire on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005007256968315.html">Wire on AliExpress</a></p>

<p><img src="https://ae-pic-a1.aliexpress-media.com/kf/S2a0fe6eaf6814accb0536a4c467851e75.jpg_960x960q75.jpg_.avif" alt="Multimeter on AliExpress" style="width:50%" /></p>

<p><a href="https://fr.aliexpress.com/item/1005005981700177.html">Multimeter on AliExpress</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">My custom LEGO storage system</title><link href="/2025/03/21/lego-storage_en.html" rel="alternate" type="text/html" title="My custom LEGO storage system" /><published>2025-03-21T03:07:57-05:00</published><updated>2025-03-21T03:07:57-05:00</updated><id>/2025/03/21/lego-storage_en</id><content type="html" xml:base="/2025/03/21/lego-storage_en.html"><![CDATA[<p><img src="/assets/2025-03-21-lego-storage/0.jpg" alt="" /></p>

<p>For a few years now, I’ve been selling LEGO pieces online, and I’ve needed to effectively organize and store my inventory. Over the years, I’ve designed and built a custom storage solution. In this article, I reflect on this adventure.</p>

<h2 id="wooden-boxes">Wooden boxes</h2>

<p>There’s a makerspace near my home equipped with a laser cutter. After a training session, I started experimenting with this machine and quickly realized its potential for making wooden boxes to store my LEGO pieces.</p>

<p>Initially, I wanted to create boxes that were as thin as possible to maximize the available space for the pieces. After a first prototype made from 1mm poplar plywood scraps I found at a modeling shop, I settled on using 3mm plywood. The compromise between sturdiness and volume was satisfactory, and it was a material that was easy to find in nearby hardware stores and relatively affordable.</p>

<p>I based the size of the first boxes on the compartments of the storage system I was using at the time, resulting in a square box measuring 75mm on each side. A box with these dimensions can hold an 8-stud-long LEGO piece with just the right amount of margin.</p>

<p>For the height, I wanted to respect the ratio of LEGO bricks, considering that my box was equivalent to a 2x2 brick. LEGO brick experts know that 2 LEGO units correspond to 5 plate heights, and a brick is 3 plates high. For a 75mm square box, the height comes to 75*3/5 = 45mm. I found that too tall, so I reduced it to 2 plates instead of 3, making it 30mm. I think this is the perfect ratio.</p>

<p>From there, assuming my base box is 2x2 units wide and 2 plates high, I experimented with a variety of sizes in 1x1, 1x2, 2x3, 2x4, 3x3, etc., in heights of 1, 2, 3, or 4 plates. I quickly realized that larger, shorter models are useful as trays to hold pieces during builds. I made larger versions that I am still using today.</p>

<p><a href="/assets/2025-03-21-lego-storage/7.jpg"><img src="/assets/2025-03-21-lego-storage/7.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/9.jpg"><img src="/assets/2025-03-21-lego-storage/9.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="proto-drawers">Proto-drawers</h2>

<p>I started to have a number of loose boxes and felt the need for a higher level of storage. Still using the laser cutter, I began by creating large boxes designed to hold several smaller boxes. This allowed me to play with the modular system and gave me a first glimpse of what a full drawer might look like. It was very encouraging.</p>

<p>I then made stackable sleeves in which the boxes could slide, and added a tab on the front face to create something resembling drawers. I was getting closer to what I had envisioned from the beginning, and it was very exciting.</p>

<p><a href="/assets/2025-03-21-lego-storage/11.jpg"><img src="/assets/2025-03-21-lego-storage/11.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/10.jpg"><img src="/assets/2025-03-21-lego-storage/10.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="real-drawers">Real drawers</h2>

<p>The outcome so far was very encouraging, but I was hitting the limits of what a laser cutter alone can do, and it was time to level up.</p>

<p>I searched for slides to create proper drawers. The feeling of quality when opening and closing the drawers was an important criterion. I wanted my drawers to give a sense of sturdiness and quality, with smooth opening and closing, without tipping as the drawer opens, and without the fear of dislodging the drawer if opened too quickly. I also wanted the drawers to be able to open fully to access even the boxes at the back.</p>

<p>After finding and ordering full-extension metal slides on Amazon, I made a first prototype with 10mm poplar plywood. I cut the pieces with a jigsaw, but the result was very mediocre. Nothing was truly straight, the opening/closing of the drawers was not smooth, and the open drawers collided with each other.</p>

<p>The makerspace that hosts the laser cutter also has a woodshop. After completing the necessary training, I undertook a second prototype, this time using a table saw. The result was much better, and I still use this prototype today, with some minor modifications.</p>

<p><a href="/assets/2025-03-21-lego-storage/15.jpg"><img src="/assets/2025-03-21-lego-storage/15.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/13.jpg"><img src="/assets/2025-03-21-lego-storage/13.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="going-larger">Going larger</h2>

<p>Encouraged by this result, I wanted to step it up by creating a piece of furniture on the same model but twice as wide. It mostly worked well, but the large continuous surface of the drawers causes the bottom to sag under the weight. Because of this, the boxes end up tightly packed together, making access more difficult, and also the drawers rub against each other.</p>

<p>The result was still encouraging, and I still use this prototype today. I also added real handles. I chose a simple yet effective model for discreet, elegant, and functional handles.</p>

<p><a href="/assets/2025-03-21-lego-storage/3.jpg"><img src="/assets/2025-03-21-lego-storage/3.jpg" alt="" />
</a></p>

<p>For the next piece of furniture, I kept the same drawer size but increased the number of drawers from 5 to 16. This starts making a good storage unit. To prevent the bottom from sagging, I added a partition that divides the drawer into two parts, helping to support the bottom. I also tested a double-height drawer to store larger pieces.</p>

<p><a href="/assets/2025-03-21-lego-storage/4.jpg"><img src="/assets/2025-03-21-lego-storage/4.jpg" alt="" />
</a></p>

<h2 id="towards-better-quality">Towards better quality</h2>

<p>So far, the furniture has been very satisfactory, and I still use them daily without major issues. However, I’m not fully satisfied with the aesthetics, particularly the inconsistent spacing between the drawers, with some being a bit crooked. I therefore sought to innovate in manufacturing techniques.</p>

<p>The main issue with previous prototypes was the proper positioning of the slides. Until now, I marked the drill points for the slides by hand, measuring directly on the boards. Having heard that another makerspace, a bit further from my home, had a CNC milling machine, I had the idea of creating grooves with the milling machine to accommodate the slides, thus allowing them to be held in place precisely.</p>

<p>After several experiments to get the hang of the machine and determine the ideal groove dimensions, I created a small piece of furniture to validate the concept. I also used the milling machine to drill the holes for the handles to ensure they were well-aligned. I wanted to achieve the best result possible. To this end, I also replaced the 10mm plywood with 19mm three-ply for a better visual finish.</p>

<p>The result met my expectations. The finish is better than all the furniture made previously. However, machining the grooves takes a lot of machine time, leading to a significant cost. This technique isn’t viable for making a large piece of furniture. So I tried something different. Instead of creating a whole groove, I simply made the drill points with the milling machine. To test this technique, I made a wide piece of furniture, but with only 5 drawers. The result wasn’t as good.</p>

<p><a href="/assets/2025-03-21-lego-storage/6.jpg"><img src="/assets/2025-03-21-lego-storage/6.jpg" alt="" />
</a></p>

<h2 id="conclusion-and-future-plans">Conclusion and future plans</h2>

<p>This project has been underway for almost 4 years now. I currently have a total of 5 pieces of furniture of varying capacities that I use daily to store my LEGO pieces for my online shop. The modular box system allows me to take out the boxes easily to retrieve pieces and reconfigure the layout in the drawers as needed, which is really enjoyable.</p>

<p>I still need more storage space, and I plan to build more furniture while always looking to improve the design. The positioning of the drawers is still not ideal without blowing the budget in machining time. I have more ideas, like using a template for drilling. I’m also thinking about a way to position the drawer fronts once the drawers are in place. I think this is the simplest way to achieve an overall optimal result without seeking perfection in the positioning of the slides. Also, the current slides don’t allow the drawer to extend beyond its depth, making access to the boxes at the back difficult, especially when there’s a handle from the drawer above right above it. One option would be to find slides that allow for greater than full extension, but I’m not sure if those exist. The simplest solution is to make the  drawers shorter than the slides.</p>

<p>For the next project, I plan to create a set with a capacity equivalent to all 5 pieces of furniture I have today. I’d like to try adding a large illustration that spans the fronts of the drawers. I’m also considering a system of connected drawers with semi-automatic opening controlled by my picking software.</p>

<p>Stay tuned.</p>

<p><a href="/assets/2025-03-21-lego-storage/1.jpg"><img src="/assets/2025-03-21-lego-storage/1.jpg" alt="" />
</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">(fr) Mon système de rangement LEGO</title><link href="/2025/03/21/lego-storage_fr.html" rel="alternate" type="text/html" title="(fr) Mon système de rangement LEGO" /><published>2025-03-21T03:07:57-05:00</published><updated>2025-03-21T03:07:57-05:00</updated><id>/2025/03/21/lego-storage_fr</id><content type="html" xml:base="/2025/03/21/lego-storage_fr.html"><![CDATA[<p><img src="/assets/2025-03-21-lego-storage/0.jpg" alt="" /></p>

<p>Depuis quelques années je fais de le vente de pièce de LEGO en ligne, et j’ai besoin de ranger et organiser efficacement mon stock de pièces.
Au cours des dernières années j’ai conçu et fabriqué une solution de rangement sur mesure.
Dans cet article je reviens sur cette aventure.</p>

<h2 id="des-boites-en-bois">Des boites en bois</h2>

<p>J’ai près de chez moi un atelier partagé équipé d’une découpeuse LASER.
Après une séance de formation, j’ai commencé à expérimenter avec cette machine, et en ai vite saisi le potentiel pour fabriquer des boites en bois pour ranger mes pièces de LEGO.</p>

<p>Je voulais au départ faire des boites qui soient les plus fines possible afin de maximiser l’espace disponible pour les pièces.
Après un premier prototype réalisé avec des chutes de contreplaqué de peuplier de 1mm récupérées dans une boutique de modélisme, je me suis fixé sur du contreplaqué de 3mm.
Le compromis entre solidité et volume était satisfaisant,
et c’était un matériau facile à trouver dans les magasins de bricolage proches de chez moi et relativement bon 
marché.</p>

<p>J’ai calqué la taille des premières boites sur la taille des compartiments du système de rangement que j’utilisais à l’époque, soit une boite carré de 75mm de côté.
Une boite avec ces dimensions peut accueillir une pièce de LEGO de 8 unités de long avec juste ce qu’il faut de marge.</p>

<p>Pour la hauteur j’ai voulu respecter le ratio des briques LEGO, en considérant que ma boite était équivalente à une brique de 2x2.
Les experts de la brique danoise savent que 2 unités LEGO correspondent à 5 hauteurs de plaque, et la hauteur d’une brique fait 3 plaques de haut.
Pour une boite de 75mm de côté on arrive donc à une hauteur de 75*3/5 = 45mm.
Je trouvais ça trop haut, alors je suis descendu à 2 plaques au lieu de 3, soit 30mm.
Je trouve que c’est le ratio parfait.</p>

<p>Partant de là, en partant du principe que ma boite de base fait 2x2 unités de large et 2 plaques de haut, j’ai expérimenté avec tout un tas de variantes en 1x1, 1x2, 2x3, 2x4, 3x3, etc en version 1, 2, 3 ou 4 plaques de hauteur. Je me suis vite rendu compte que les modèles de grande taille et faible hauteur sont utiles en tant que plateau pour contenir des pièces lors de constructions par exemples.
J’en ai fait des plus grands, que j’utilise encore couramment aujourd’hui.</p>

<p><a href="/assets/2025-03-21-lego-storage/7.jpg"><img src="/assets/2025-03-21-lego-storage/7.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/9.jpg"><img src="/assets/2025-03-21-lego-storage/9.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="des-proto-tiroirs">Des proto-tiroirs</h2>

<p>Je commençais à avoir un certain nombre de boites en vrac et le besoin d’un niveau supérieur de rangement se faisait sentir.
Toujours en découpe LASER, j’ai commencé par créer des grandes boites destinées à accueillir plusieurs petites boites.
Ça m’a permi de jouer avec le système modulaire et donné un premier apperçu de ce qu’un tiroir plein pourrait donner.
C’était très encourageant.</p>

<p>J’ai ensuite fabriqué des manchons empilables dans lesquels les casiers pouvaient glisser,
et ajouté une languette sur la face avant,
pour faire quelque chose qui ressemble à des tiroirs.
Je me rapprochais de ce que j’avais en tête depuis le début, et c’était très excitant.</p>

<p><a href="/assets/2025-03-21-lego-storage/11.jpg"><img src="/assets/2025-03-21-lego-storage/11.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/10.jpg"><img src="/assets/2025-03-21-lego-storage/10.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="des-vrais-tiroirs">Des vrais tiroirs</h2>

<p>Le rendu jusque là était très encourageant, mais je touchais aux limites de la découpe LASER,
et il était temps de passer au niveau supérieur.</p>

<p>J’ai cherché des glissières pour faire des tiroirs en bonne et due forme.
La sensation de qualité à l’ouverture et fermeture des tiroirs était un critère important.
Je voulais que mes tiroirs donnent une impression de solidité et de qualité,
avec une ouverture et fermeture fluide,
sans pencher à mesure que le tiroir s’ouvre,
et sans peur de déloger le tiroir si on ouvre un peu trop vite.
Je voulais aussi que les tiroirs puissent s’ouvrir sur la totalité de la profondeur pour permettre d’accéder même aux boites du fond.</p>

<p>Après avoir trouvé et commandé des glissières métalliques à sortie totale sur Amazon,
j’ai fabriqué un premier prototype de meuble avec du contreplaqué de peuplier de 10mm.
J’ai découpé les pièces avec une scie sauteuse mais le résultat était très moyen.
Rien n’était vraiment droit, et l’ouverture/fermeture des tiroirs n’était pas fluide
et les tiroirs ouverts entraient en collision.</p>

<p>L’atelier partagé qui héberge la découpe LASER possède également un atelier bois.
Après avoir fait les formations nécessaires, 
j’ai entrepris un second prototype, en utilisant cette fois la scie circulaire sur table.
Le résultat était nettement meilleur.
J’utilise encore aujourd’hui ce prototype, avec quelques modification mineures.</p>

<p><a href="/assets/2025-03-21-lego-storage/15.jpg"><img src="/assets/2025-03-21-lego-storage/15.jpg" alt="" width="49%" style="float: left; padding-bottom: 1rem;" />
</a></p>

<p><a href="/assets/2025-03-21-lego-storage/13.jpg"><img src="/assets/2025-03-21-lego-storage/13.jpg" alt="" width="49%" style="float: right; padding-bottom: 1rem;" />
</a></p>

<h2 style="clear: both" id="des-meubles-plus-grands">Des meubles plus grands</h2>

<p>Fort de ce résultat,
j’ai voulu passer à la vitesse supérieure en créant un meuble sur le même modèle mais deux fois plus large.
Ça a globalement bien fonctionné,
mais la grande surface continue des tiroirs fait que le fond s’affaisse avec le poids du chargement.
À cause de ça, les boites se retrouvent serrées les unes contre les autres, ce qui rend l’accès plus difficle,
et les tiroirs frottent les uns sur les autres.</p>

<p>Le résultat était cependant encourageant, et j’utilise encore ce meuble aujourd’hui.
J’ai également ajouté des vraies poignées.
J’ai choisi un modèle simples mais efficace, pour des poignées discrètes, élégantes et fonctionnelles.</p>

<p><a href="/assets/2025-03-21-lego-storage/3.jpg"><img src="/assets/2025-03-21-lego-storage/3.jpg" alt="" />
</a></p>

<p>Pour le meuble suivant j’ai gardé la même taille de tiroir 
mais augmenté le nombre de tiroirs de 5 à 16.
Là on commence à avoir un bon meuble de rangement.
Pour éviter que le fond ne s’affaisse, j’ai ajouté une cloison qui coupe le tiroir en deux parties et permet de maintenir le fond.
J’ai également testé un tiroir double hauteur pour pouvoir ranger des pièces plus volumineuses.</p>

<p><a href="/assets/2025-03-21-lego-storage/4.jpg"><img src="/assets/2025-03-21-lego-storage/4.jpg" alt="" />
</a></p>

<h2 id="vers-plus-de-qualité">Vers plus de qualité</h2>

<p>Jusque là les meubles sont très satisfaisants, et je les utilise encore au quotidien sans soucis majeur.
Cependant, je ne suis pas pleinement satisfait de l’esthétique,
notamment le fait que l’espacement entre les tiroirs n’est pas régulier,
et certains sont même un peu de travers.
J’ai donc cherché à innover dans les techniques de fabrication.</p>

<p>La problématique principale des prototypes précédents était le bon positionnement des glissières.
Jusque là je marquais les perçages pour les glissières à la main en mesurant directement sur les planches.
Ayant eu vent qu’un autre atelier partagé, un peu plus loin de chez moi, possèdait une fraiseuse numérique,
j’ai eu l’idée de créer à la fraiseuse des rainures qui viendraient accueillir les glissières,
permettant ainsi de les maintenir en position de manière précise.</p>

<p>Après plusieurs expérimentations pour prendre en main la machine et déterminer les dimensions idéales des rainures, j’ai réalisé un petit meuble pour valider le concept.
J’ai aussi utilisé la fraiseuse pour percer les trous pour les poignées afin qu’elles soient bien alignées les unes avec les autres.
Je voulais essayer d’atteindre un résultat le plus parfait possible.
À cette fin, j’ai également remplacé le CP de 10mm par du 3 plis de 19mm pour un meilleur rendu visuel.</p>

<p>Le résultat a été à la hauteur de mes attentes.
Le rendu est meilleur que tous les meubles réalisés auparavant.
Cependant, l’usinage des rainures demande beaucoup de temps machine,
ce qui engendre un coût non négligeable.
Cette technique n’est pas viable pour faire un grand meuble.
J’ai donc essayé autre chose.
Au lieu de faire toute une rainure, j’ai simplement fait les perçages à la fraiseuse.
Pour tester cette technique j’ai fait un meuble grande largeur, mais avec seulement 5 tiroirs.
Le résultat n’est pas aussi bon.</p>

<p><a href="/assets/2025-03-21-lego-storage/6.jpg"><img src="/assets/2025-03-21-lego-storage/6.jpg" alt="" />
</a></p>

<h2 id="bilan-et-perspective">Bilan et perspective</h2>

<p>Ce projet est lancé depuis presque 4 ans maintenant.
Je dispose aujourd’hui d’un total de 5 meubles de différentes capacités que j’utilise au quotidien pour ranger mes pièces de LEGO pour ma boutique en ligne.
Le système de boites modulaires me permet de sortir les boîtes pour facilement prélever les pièces,
et de reconfigurer l’agencement dans les tiroirs en fonction des besoins,
et c’est vraiment très appréciable.</p>

<p>J’ai toujours besoin de plus de place de rangement,
et je prévois de fabriquer encore d’autres meubles,
en cherchant toujours à améliorer la conception.
Le positionnement des tiroirs n’est toujours pas idéal sans exploser le budger en temps d’usinage.
J’ai encore des idées, comme l’utilisation d’un gabarit pour les perçages.
Je réfléchis aussi à une manière de positionner les façades des tiroirs une fois les tiroirs en place.
Je pense que c’est le plus simple pour atteindre un rendu global optimal sans chercher la perfection
dans le positionnement des glissières.
Aussi, les glissières actuelles ne permettent pas au tiroir de sortir plus que sa profondeur,
ce qui rend encore l’accès aux boites du fond difficile,
surtout quand il y a la poignée du tiroir du dessus juste au dessus.
Une option serait de trouver des glissières qui permettent une sortie plus que totale,
mais je ne suis pas sûr que ça existe.
La solution la plus simple est de faire des tiroirs plus courts que les glissières.</p>

<p>Pour le prochain projet j’envisage de faire dans le même jet un ensemble de capacité équivalente
à l’ensemble des 5 meubles que j’ai aujourd’hui.
Je voudrais essayer d’ajouter une grande illustration qui s’étale sur les façades des tiroirs.
Je réfléchis également à un système de tiroirs connectés, avec ouverture semie-automatique pilotée par mon logiciel de picking.</p>

<p>Stay tuned.</p>

<p><a href="/assets/2025-03-21-lego-storage/1.jpg"><img src="/assets/2025-03-21-lego-storage/1.jpg" alt="" />
</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">(fr) Reconnaissance vocale dans une app SwiftUI</title><link href="/2025/03/14/swiftui-speech_fr.html" rel="alternate" type="text/html" title="(fr) Reconnaissance vocale dans une app SwiftUI" /><published>2025-03-14T04:23:06-05:00</published><updated>2025-03-14T04:23:06-05:00</updated><id>/2025/03/14/swiftui-speech_fr</id><content type="html" xml:base="/2025/03/14/swiftui-speech_fr.html"><![CDATA[<p>Dans un précédent article, nous avons vu l’accès au microphone dans une application SwiftUI sur macOS.
Dans cet article nous allons ajouter la reconnaissance vocale avec le framework <a href="https://developer.apple.com/documentation/speech">Speech</a>.</p>

<h2 id="vérifier-la-permission">Vérifier la permission</h2>

<p>Comme pour l’accès au micro, l’utilisateur•ice doit autoriser notre app à utiliser la reconnaissance vocale.
Le principe est similaire à la permission micro,
les cas possibles sont: autorisé, refusé/restreint ou indéterminé.</p>

<p>Comme pour le micro, je commence par ajouter dans le contrôleur un un booléen optionnel qui reflètera l’état de l’autorisation d’accès à la reconnaissance vocale, j’affiche la valeur de l’autorisation dans la vue, et je modifie la propriété <code class="language-plaintext highlighter-rouge">ready</code> pour prendre en compte la reconnaissance vocale.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition authorisation"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La fonction système qui indique l’autorisation de la reconnaissance vocale est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.authorizationStatus()</code>.
Comme pour le micro, je crée une propriété calculée dans le contrôleur pour encapsuler l’appel à la fonction système, et une fonction qui met à jour la propriété observable en fonction de la valeur brute de la permission, et je fais une première mise à jour dans l’initialiseur.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Speech</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorisationStatus</span><span class="p">:</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">speechRecognitionAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">speechRecognitionAuthorisationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="demander-la-permission">Demander la permission</h2>

<p>La fonction système pour demander la permission est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.requestAuthorization(:)</code>.
Elle renvoie la valeur de l’autorisation dans une closure.
Comme pour le micro, je crée une fonction qui encapsule l’appel à la fonction système et renvoie la valeur de l’autorisation.
J’utilise <code class="language-plaintext highlighter-rouge">withCheckedContinuation(:)</code> pour utiliser <code class="language-plaintext highlighter-rouge">async/await</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">requestSpeechRecognitionAuthorisation</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">withCheckedContinuation</span> <span class="p">{</span> <span class="n">continuation</span> <span class="k">in</span>
            <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="n">requestAuthorization</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span>
                <span class="n">continuation</span><span class="o">.</span><span class="nf">resume</span><span class="p">(</span><span class="nv">returning</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAuthorisationStatus</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Comme pour le micro, on peut appeler la méthode <code class="language-plaintext highlighter-rouge">requestSpeechRecognitionAuthorisation()</code> de manière systématique pour récupérer l’état de l’autorisation, la question n’est posée à l’utilisateur que si nécessaire.</p>

<p>J’appelle cette fonction dans <code class="language-plaintext highlighter-rouge">start()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">let</span> <span class="nv">speechRecognitonStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestSpeechRecognitionAuthorisation</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">speechRecognitonStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition not authorized (</span><span class="se">\(</span><span class="n">speechRecognitonStatus</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La commande suivante permet de réinitialiser la demande de permission, utile en développement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset SpeechRecognition &lt;bundle.id&gt;
</code></pre></div></div>

<h2 id="initialisation-et-vérification-de-la-disponibilité">Initialisation et vérification de la disponibilité</h2>

<p>Tout est désormais prêt pour démarrer la reconnaissance vocale.
La classe principale est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>.
Dans le contrôleur j’ajoute une propriété qui permettra de stocker une instance de cette classe.
Bien que le contrôleur pourra démarrer et arrêter la reconnaissance vocale à loisir,
une seule instance de <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> est nécessaire.</p>

<p>Par défaut la reconnaissance vocale reconnait la langue configurée sur l’appareil,
mais il est possible de passer une locale spécifique.
Ici je force la langue française dans sa variante de France.</p>

<p>La reconnaissance vocale peut ne pas être disponible sur un appareil donné à un instant donné,
notamment par rapport à l’état de la connexion Internet.
La disponibilité en temps réel est donnée par la fonction <code class="language-plaintext highlighter-rouge">SFSpeechRecognizerDelegate.speechRecognizer(_:availabilityDidChange:)</code>.
J’implémente cette fonction sur le contrôleur et configure le <code class="language-plaintext highlighter-rouge">delegate</code> de l’objet <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>.
À noter qu’il existe aussi la propriété <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.isAvailable</code> qui permet d’interroger directement la disponibilité.</p>

<p>Pour une expérience utilisateur optimale, il est préférable d’ajuster l’affichage et le comportement de l’application selon la possibilité d’utiliser ou non la reconnaissance vocale dès le démarrage.
Si on attend que l’utilisateur•ice essaie d’accéder aux fonctionnalités associées pour le vérifier,
on risque de créer de la frustration si ces fonctionnalités s’avèrent indisponibles.
J’initialise donc l’instance <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> dans l’initialiseur.</p>

<p>Dans la vue j’affiche la disponibilité de la reconnaissance vocale, et je modifie <code class="language-plaintext highlighter-rouge">ready</code> pour prendre en compte cette nouvelle donnée.
Dans ce cas, on n’autorise que si on est sûr que la fonctionnalité est disponible.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition availability"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">available</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">available</span> <span class="p">?</span> <span class="s">"Available"</span> <span class="p">:</span> <span class="s">"Unavailable"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">!=</span> <span class="kc">true</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">SFSpeechRecognizerDelegate</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">speechRecognitionAvailable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="c1">// ...</span>
        <span class="c1">// init speech recognizer with forced locale</span>
        <span class="k">let</span> <span class="nv">locale</span> <span class="o">=</span> <span class="kt">Locale</span><span class="p">(</span><span class="nv">identifier</span><span class="p">:</span> <span class="s">"fr_FR"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">recognizer</span> <span class="o">=</span> <span class="kt">SFSpeechRecognizer</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="n">locale</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Unable to create a SFSpeechRecognizer object with locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">speechRecognizer</span> <span class="o">=</span> <span class="n">recognizer</span>
        <span class="n">speechRecognizer</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition ready, using locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">speechRecognizer</span><span class="p">(</span><span class="n">_</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="p">,</span> <span class="n">availabilityDidChange</span> <span class="nv">available</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">=</span> <span class="n">available</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="démarrage-de-la-reconnaissance-et-traitement-des-résultats">Démarrage de la reconnaissance et traitement des résultats</h2>

<p>On peut maintenant lancer la reconnaissance vocale à proprement parler lorsque l’utilisateur•ice clique sur <strong>Start</strong>.
Je commence par créer des fonctions <code class="language-plaintext highlighter-rouge">startRecognition()</code> et <code class="language-plaintext highlighter-rouge">stopRecognition()</code>, que j’appelle respectivement dans <code class="language-plaintext highlighter-rouge">start()</code> et <code class="language-plaintext highlighter-rouge">stop()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ... (check permissions)</span>
        <span class="c1">// ... (start audio)</span>
        
        <span class="nf">startRecognition</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition active"</span><span class="p">)</span>
        
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">stopRecognition</span><span class="p">()</span>
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pour une session de reconnaissance nous avons besoin d’une instance de <code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code> et <code class="language-plaintext highlighter-rouge">SFSpeechRecognitionTask</code>.
J’ajoute deux propriétés correspondantes dans le contrôleur.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionRequest</span><span class="p">:</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="o">!</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionTask</span><span class="p">:</span> <span class="kt">SFSpeechRecognitionTask</span><span class="o">!</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On commence par initialiser une requête.
Ensuite il faut alimenter la requête avec les données audio issues du micro.
Pour cela on utilise le “tap” mis en place précédement.
Enfin, on lance une tâche de reconnaissance vocale à partir de la requête.
Les résultats sont envoyés à une closure au fur et à mesure que la personne parle.
<code class="language-plaintext highlighter-rouge">result.bestTranscription</code> contient la transcription des paroles prononcées.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">recognitionRequest</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="n">speechRecognizer</span><span class="o">.</span><span class="nf">recognitionTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">recognitionRequest</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">result</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">recognizedText</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">bestTranscription</span><span class="o">.</span><span class="n">formattedString</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pour l’arrêt de la reconnaissance, on peut appeler <code class="language-plaintext highlighter-rouge">recognitionTask.finish()</code> et <code class="language-plaintext highlighter-rouge">recognitionRequest.endAudio()</code>, et enlever le tap.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="n">recognitionRequest</span><span class="p">?</span><span class="o">.</span><span class="nf">endAudio</span><span class="p">()</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">recognitionTask</span><span class="p">?</span><span class="o">.</span><span class="nf">finish</span><span class="p">()</span>
        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Et voilà, tout est fonctionnel.</p>

<p><img src="/assets/2025-03-14-swiftui-speech/1.gif" alt="" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Dans un précédent article, nous avons vu l’accès au microphone dans une application SwiftUI sur macOS. Dans cet article nous allons ajouter la reconnaissance vocale avec le framework Speech.]]></summary></entry><entry><title type="html">Speech Recognition in a SwiftUI App</title><link href="/2025/03/14/swiftui-speech_en.html" rel="alternate" type="text/html" title="Speech Recognition in a SwiftUI App" /><published>2025-03-14T04:23:06-05:00</published><updated>2025-03-14T04:23:06-05:00</updated><id>/2025/03/14/swiftui-speech_en</id><content type="html" xml:base="/2025/03/14/swiftui-speech_en.html"><![CDATA[<p>In a previous article, we explored microphone access in a SwiftUI application on macOS. In this article, we will add speech recognition using the <a href="https://developer.apple.com/documentation/speech">Speech</a> framework.</p>

<h2 id="checking-permissions">Checking permissions</h2>

<p>As with microphone access, the user must grant our app permission to use speech recognition. The principle is similar to microphone permission, and the possible statuses are: granted, denied/restricted, or undetermined.</p>

<p>Like with the microphone, I start by adding an optional boolean in the controller to reflect the status of speech recognition access permission, display the authorization value in the view, and modify the <code class="language-plaintext highlighter-rouge">ready</code> property to account for speech recognition.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition authorization"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The system function that indicates speech recognition authorization is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.authorizationStatus()</code>.
Similar to the microphone, I create a computed property in the controller to encapsulate the system function call, along with a function that updates the observable property based on the raw permission value, and I perform an initial update in the initializer.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Speech</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorizationStatus</span><span class="p">:</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">speechRecognitionAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">speechRecognitionAuthorizationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="requesting-permission">Requesting permission</h2>

<p>The system function to request permission is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.requestAuthorization(:)</code>. It returns the authorization value in a closure. Similar to the microphone, I create a function that encapsulates the system function call and returns the authorization value. I use <code class="language-plaintext highlighter-rouge">withCheckedContinuation(:)</code> to utilize <code class="language-plaintext highlighter-rouge">async/await</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">requestSpeechRecognitionAuthorization</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">withCheckedContinuation</span> <span class="p">{</span> <span class="n">continuation</span> <span class="k">in</span>
            <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="n">requestAuthorization</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span>
                <span class="n">continuation</span><span class="o">.</span><span class="nf">resume</span><span class="p">(</span><span class="nv">returning</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAuthorizationStatus</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As with the microphone, the <code class="language-plaintext highlighter-rouge">requestSpeechRecognitionAuthorization()</code> method can be called systematically to retrieve the authorization state, and the user is prompted only if necessary.</p>

<p>I call this function in <code class="language-plaintext highlighter-rouge">start()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">let</span> <span class="nv">speechRecognitionStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestSpeechRecognitionAuthorization</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">speechRecognitionStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition not authorized (</span><span class="se">\(</span><span class="n">speechRecognitionStatus</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following command resets the permission request, which is useful during development.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset SpeechRecognition &lt;bundle.id&gt;
</code></pre></div></div>

<h2 id="initialization-and-availability-check">Initialization and availability check</h2>

<p>Everything is now ready to start speech recognition. The main class is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>. In the controller, I add a property to store an instance of this class. Although the controller can start and stop speech recognition at will, only one instance of <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> is needed.</p>

<p>By default, speech recognition recognizes the language configured on the device, but it is possible to specify a specific locale. Here, I force the French language in its France variant.</p>

<p>Speech recognition may not be available on a given device at a certain time, particularly regarding the state of the Internet connection. Real-time availability is provided by the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizerDelegate.speechRecognizer(_:availabilityDidChange:)</code> function. I implement this function in the controller and configure the <code class="language-plaintext highlighter-rouge">delegate</code> of the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> object. Note that there is also the property <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.isAvailable</code> that allows direct querying of availability.</p>

<p>For an optimal user experience, it is best to adjust the display and behavior of the application based on the availability of speech recognition from the start. If we wait for the user to try accessing related features to check for availability, it may lead to frustration if these features turn out to be unavailable. Thus, I initialize the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> instance in the initializer.</p>

<p>In the view, I display the availability of speech recognition and modify <code class="language-plaintext highlighter-rouge">ready</code> to account for this new information. In this case, we only allow access if we are sure the functionality is available.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition availability"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">available</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">available</span> <span class="p">?</span> <span class="s">"Available"</span> <span class="p">:</span> <span class="s">"Unavailable"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">!=</span> <span class="kc">true</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">SFSpeechRecognizerDelegate</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">speechRecognitionAvailable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="c1">// ...</span>
        <span class="c1">// init speech recognizer with forced locale</span>
        <span class="k">let</span> <span class="nv">locale</span> <span class="o">=</span> <span class="kt">Locale</span><span class="p">(</span><span class="nv">identifier</span><span class="p">:</span> <span class="s">"fr_FR"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">recognizer</span> <span class="o">=</span> <span class="kt">SFSpeechRecognizer</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="n">locale</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Unable to create a SFSpeechRecognizer object with locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">speechRecognizer</span> <span class="o">=</span> <span class="n">recognizer</span>
        <span class="n">speechRecognizer</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition ready, using locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">speechRecognizer</span><span class="p">(</span><span class="n">_</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="p">,</span> <span class="n">availabilityDidChange</span> <span class="nv">available</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">=</span> <span class="n">available</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="starting-recognition-and-processing-results">Starting recognition and processing results</h2>

<p>We can now start speech recognition when the user clicks <strong>Start</strong>. I begin by creating <code class="language-plaintext highlighter-rouge">startRecognition()</code> and <code class="language-plaintext highlighter-rouge">stopRecognition()</code> functions, which I call respectively in <code class="language-plaintext highlighter-rouge">start()</code> and <code class="language-plaintext highlighter-rouge">stop()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ... (check permissions)</span>
        <span class="c1">// ... (start audio)</span>
        
        <span class="nf">startRecognition</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition active"</span><span class="p">)</span>
        
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">stopRecognition</span><span class="p">()</span>
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For a recognition session, we need an instance of <code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code> and <code class="language-plaintext highlighter-rouge">SFSpeechRecognitionTask</code>. I add two corresponding properties in the controller.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionRequest</span><span class="p">:</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="o">!</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionTask</span><span class="p">:</span> <span class="kt">SFSpeechRecognitionTask</span><span class="o">!</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We start by initializing a request. Next, we need to feed the request with audio data from the microphone. For this, we use the “tap” set up previously. Finally, we launch a speech recognition task from the request. The results are sent to a closure as the person speaks, and <code class="language-plaintext highlighter-rouge">result.bestTranscription</code> contains the transcription of the spoken words.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">recognitionRequest</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="n">speechRecognizer</span><span class="o">.</span><span class="nf">recognitionTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">recognitionRequest</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">result</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">recognizedText</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">bestTranscription</span><span class="o">.</span><span class="n">formattedString</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To stop recognition, we can call <code class="language-plaintext highlighter-rouge">recognitionTask.finish()</code> and <code class="language-plaintext highlighter-rouge">recognitionRequest.endAudio()</code>, and remove the tap.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="n">recognitionRequest</span><span class="p">?</span><span class="o">.</span><span class="nf">endAudio</span><span class="p">()</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">recognitionTask</span><span class="p">?</span><span class="o">.</span><span class="nf">finish</span><span class="p">()</span>
        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And there, everything is working.</p>

<p><img src="/assets/2025-03-14-swiftui-speech/1.gif" alt="" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[In a previous article, we explored microphone access in a SwiftUI application on macOS. In this article, we will add speech recognition using the Speech framework.]]></summary></entry><entry><title type="html">Swift Observation: in-depth analysis</title><link href="/2025/03/06/swift-observation_en.html" rel="alternate" type="text/html" title="Swift Observation: in-depth analysis" /><published>2025-03-06T04:23:15-06:00</published><updated>2025-03-06T04:23:15-06:00</updated><id>/2025/03/06/swift-observation_en</id><content type="html" xml:base="/2025/03/06/swift-observation_en.html"><![CDATA[<p>Introduced in 2023, the <a href="https://developer.apple.com/documentation/observation">Observation</a> framework aims to simplify existing reactive mechanisms while improving application performance.</p>

<p>This new approach relies on the automatic tracking of data accesses via the <a href="https://developer.apple.com/documentation/observation/withobservationtracking(_:onchange:)"><code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code></a> method.</p>

<p>In this article, we will experiment with this method to understand how it works and its limitations.</p>

<h2 id="general-principles">General principles</h2>

<p>The Observation framework is based on the use of reference types. The <a href="https://developer.apple.com/documentation/observation/observable()"><code class="language-plaintext highlighter-rouge">@Observable</code></a> macro can only be applied to classes, not structures. Therefore, applications relying on value semantics will first need to transition to reference semantics, a task that can be complex.</p>

<p>A class annotated with <code class="language-plaintext highlighter-rouge">@Observable</code> detects and records accesses to its properties. Only accesses to stored properties are taken into account. However, access can be indirect, for example, through a function or a computed property. If a chain of calls ultimately results in access to a stored property, Observation detects it.</p>

<p>Both read and write accesses are detected. Read accesses are used to identify dependencies, while write accesses send change notifications.</p>

<h2 id="a-simple-example">A simple example</h2>

<p>Note: All code presented works as is in a playground.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>In this example, we declare an observable class with a simple property and create an instance of it. We access the object’s property in the <code class="language-plaintext highlighter-rouge">apply</code> block of <code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code>. The read access is detected and recorded. Finally, by modifying the property’s value from outside, the write access is also detected, resulting in the invocation of the <code class="language-plaintext highlighter-rouge">onChange</code> block.</p>

<h2 id="observation-is-attached-with-read-access">Observation is attached with read access</h2>

<p>If we modify the code to perform a write access instead of a read access in the <code class="language-plaintext highlighter-rouge">apply</code> block, we find that the change is not detected:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"write"</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
</code></pre></div></div>

<p>It turns out that only read accesses connect the observation. This makes sense: a component that only writes does not need to be informed of value changes.</p>

<h2 id="the-write-access-always-triggers-the-notification">The write access always triggers the notification</h2>

<p>If we write to the property by passing a value identical to the existing value, the change notification is still sent:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"test"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Write accesses always trigger a change event, even if the value does not actually change. If the developer wants to trigger the event only if the value actually changes, it’s up to them to ensure that they write to the variable only if the new value is different.</p>

<h2 id="only-read-properties-are-observed">Only read properties are observed</h2>

<p>By adding a second property, we find that only a change to the property read in <code class="language-plaintext highlighter-rouge">apply</code> triggers a change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str2
str2 changed
</code></pre></div></div>

<p>Only the blocks attached to the properties that change are called. This represents a major improvement over previous techniques, where the object as a whole was observed. This increased granularity can enhance performance by limiting updates to the parts that are actually affected.</p>

<h2 id="in-depth-study-value-semantics">In-depth study: value semantics</h2>

<p>For types with value semantics, which include all primitive types, as well as arrays and dictionaries, and also structures, the change notification is sent as soon as the value changes.</p>

<p>We have already seen examples earlier for primitive types like <code class="language-plaintext highlighter-rouge">String</code>. The case of arrays, dictionaries, and structures is interesting, albeit entirely logical.</p>

<h3 id="arrays">Arrays</h3>

<p>In the case of an array, changing a value in the array changes the overall value of the array, thus sending a change to any observer attached to all or part of the array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s">"test1"</span><span class="p">,</span> <span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[0] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[1] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing arr[0]"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing arr[1]
arr changed
arr[0] changed
arr[1] changed
</code></pre></div></div>

<h3 id="dictionaries">Dictionaries</h3>

<p>The same principle applies to dictionaries:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">:</span> <span class="s">"test1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">:</span> <span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['1'] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"2"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['2'] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing dict['1']"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing dict['2']
dict changed
dict['1'] changed
dict['2'] changed
</code></pre></div></div>

<h3 id="structures">Structures</h3>

<p>Similarly for structures, changing a member changes its total value:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">TestValue</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">TestValue</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing value.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing value.str1
value changed
value.str1 changed
value.str2 changed
</code></pre></div></div>

<h2 id="in-depth-study-reference-semantics">In-depth study: reference semantics</h2>

<p>For types with reference semantics, the change notification is sent as soon as the reference changes. Consequently, all accesses to the properties of the referenced objects also receive the update:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref
ref changed
ref.str changed
</code></pre></div></div>

<p>Note that, as seen earlier, the change is triggered even if no value actually changes (<code class="language-plaintext highlighter-rouge">ref.str</code> remains <code class="language-plaintext highlighter-rouge">"test"</code> before and after, and we would have the same result if we had done <code class="language-plaintext highlighter-rouge">test.ref = test.ref</code>).</p>

<h3 id="changes-in-a-referenced-object">Changes in a referenced object</h3>

<p>Unlike the structures seen earlier, by default, writing to a property in a reference object does not trigger a change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
</code></pre></div></div>

<p>To ensure that this is the case, we simply need to make the class <code class="language-plaintext highlighter-rouge">@Observable</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
ref.str changed
</code></pre></div></div>

<p>Note that in this case, unlike the structure, no change is triggered on <code class="language-plaintext highlighter-rouge">ref</code>, because it is the reference that matters, and here it is not affected.</p>

<h2 id="reduction-of-changes">Reduction of changes</h2>

<p>When multiple write accesses cause the same change, only one event is triggered:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="kt">Task</span> <span class="p">{</span> <span class="kd">@MainActor</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str1 and/or ref.str2 changed"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Original values"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new1"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new2"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original values
str1: test1
str2: test2
Changing ref.str1
Changing ref.str2
ref.str1 and/or ref.str2 changed
str1: new1
str2: new2
</code></pre></div></div>

<p>This example is somewhat complex. An example in a SwiftUI app is more illustrative:</p>

<p><em>This code does not work in a playground. You need to create an app.</em></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>  
            <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View update"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str1"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str1"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str2"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change both"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing both"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Result:</p>

<p><img src="/assets/2025-03-06-swift-observation/1.gif" alt="" /></p>

<p>When we click on <strong>Change both</strong>, we notice that only one <code class="language-plaintext highlighter-rouge">View update</code> is emitted, even though both values are updated simultaneously. This indicates optimized performance, where views are recalculated only once, regardless of the number of modifications made to the object.</p>

<h2 id="changing-a-referenced-object-example-in-a-swiftui-app">Changing a referenced object, example in a SwiftUI app</h2>

<p>If we replace an object instead of modifying only the changing properties, we trigger a change at the object level, causing an update of all views that depend on its properties, even if those properties do not change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">View1</span><span class="p">()</span>
            <span class="kt">View2</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change ref"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">environment</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View1</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View1 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View2</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View2 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Result:</p>

<p><img src="/assets/2025-03-06-swift-observation/2.gif" alt="" /></p>

<p>When clicking on <strong>Change ref</strong>, we find that both views update, even if the displayed data did not change. To optimize performance, it is therefore preferable to modify only the properties that have actually changed.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Observation framework represents a significant advancement in managing reactivity within Swift applications. By offering fine-grained change tracking, it optimizes performance while simplifying dependency management. Developers must, however, keep in mind the need to transition to reference semantics and to manage read and write accesses judiciously.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduced in 2023, the Observation framework aims to simplify existing reactive mechanisms while improving application performance.]]></summary></entry><entry><title type="html">(fr) Swift Observation: étude approfondie</title><link href="/2025/03/06/swift-observation_fr.html" rel="alternate" type="text/html" title="(fr) Swift Observation: étude approfondie" /><published>2025-03-06T04:23:15-06:00</published><updated>2025-03-06T04:23:15-06:00</updated><id>/2025/03/06/swift-observation_fr</id><content type="html" xml:base="/2025/03/06/swift-observation_fr.html"><![CDATA[<p>Introduit en 2023, le framework <a href="https://developer.apple.com/documentation/observation">Observation</a>
vise à simplifier les mécanismes existant en matière de réactivité tout en améliorant les performances des applications.</p>

<p>Cette nouvelle approche repose sur le tracking automatique des accès aux données
via la méthode <a href="https://developer.apple.com/documentation/observation/withobservationtracking(_:onchange:)"><code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code></a>.</p>

<p>Dans cet article nous allons jouer avec cette méthode pour en comprendre le fonctionnement et les limitations.</p>

<h2 id="fonctionnement-général">Fonctionnement général</h2>

<p>Le framework Observation repose sur l’utilisation de types de référence. La macro <a href="https://developer.apple.com/documentation/observation/observable()"><code class="language-plaintext highlighter-rouge">@Observable</code></a> ne peut être appliquée qu’aux classes, excluant ainsi les structures. Par conséquent, les applications s’appuyant sur une sémantique de valeur devront d’abord effectuer une transition vers une sémantique de référence, une tâche qui peut s’avérer complexe selon les contextes.</p>

<p>Une classe annotée avec <code class="language-plaintext highlighter-rouge">@Observable</code> détecte et mémorise les accès à ses propriétés.
Seuls les accès aux propriétés stockées sont pris en compte.
Cependant, l’accès peut-être indirect, par exemple via une fonction ou une propriété calculée.
Si une chaine d’appels résulte <em>in fine</em> en en accès à une propriété stockée, Observation le détecte.</p>

<p>Les accès en lecture et écriture sont détectés.
Les accès en lecture servent à identifier les dépendances,
les accès en écriture à envoyer les notifications de changement.</p>

<h2 id="un-exemple-simple">Un exemple simple</h2>

<p>Remarque : Tous les codes présentés fonctionnent tel quel dans une <em>playground</em>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Dans cet exemple, nous déclarons une classe observable avec une propriété simple et créons une instance de celle-ci. Nous accédons à la propriété de l’objet dans le bloc <code class="language-plaintext highlighter-rouge">apply</code> de <code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code>.
L’accès en lecture est détecté et mémorisé. Enfin, en modifiant la valeur de la propriété à l’extérieur, l’accès en écriture est également détecté, entraînant l’appel du bloc <code class="language-plaintext highlighter-rouge">onChange</code>.</p>

<h2 id="cest-laccès-en-lecture-qui-attache-lobservation">C’est l’accès en lecture qui attache l’observation</h2>

<p>Si nous modifions le code pour effectuer un accès en écriture plutôt qu’en lecture dans le bloc <code class="language-plaintext highlighter-rouge">apply</code>, nous constatons que le changement n’est pas détecté :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"write"</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
</code></pre></div></div>

<p>Il s’avère donc que seuls les accès en lecture permettent de connecter l’observation. Cette logique est cohérente : un composant qui ne fait qu’écrire n’a pas besoin d’être informé des changements de valeur.</p>

<h2 id="laccès-en-écriture-déclenche-toujours-la-notification">L’accès en écriture déclenche <em>toujours</em> la notification</h2>

<p>Si nous accédons en écriture à la propriété en passant une valeur identique à la valeur existante, la notification de changement est toujours envoyée :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"test"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Les accès en écriture déclenchent donc toujours un événement de changement, même si la valeur ne change pas dans la pratique. Si nous voulons déclencher l’événement seulement si la valeur change réellement, charge à nous de nous assurer d’écrire la variable seulement si la nouvelle valeur est différente.</p>

<h2 id="seules-les-propriétées-lues-sont-observées">Seules les propriétées lues sont observées</h2>

<p>En ajoutant une seconde propriété, nous constatons que seul un changement à la propriété lue dans <code class="language-plaintext highlighter-rouge">apply</code> déclenche un changement :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str2
str2 changed
</code></pre></div></div>

<p>Seuls les blocs attachés aux propriétés qui changent sont appelés. Cela constitue une amélioration majeure par rapport aux techniques précédentes, où l’objet dans son ensemble était observé. Cette granularité accrue peut améliorer les performances en limitant les mises à jour aux parties réellement concernées.</p>

<h2 id="étude-approfondie--sémantique-de-valeur">Étude approfondie : sémantique de valeur</h2>

<p>Pour les types avec une sémantique de valeur, ce qui comprend notamment tous types les primitifs, ainsi que les tableaux et les dictionnaires, mais aussi les structures, la notification de changement est envoyée dès que la valeur change.</p>

<p>Nous avons déjà vu des exemples plus haut pour les types primitifs comme <code class="language-plaintext highlighter-rouge">String</code>.
Le cas des tableaux, dictionnaires et structures et intéressant, bien que tout à fait logique.</p>

<h3 id="tableaux">Tableaux</h3>

<p>Dans le cas d’un tableau, changer une valeur dans le tableau change la valeur totale du tableau, et envoie donc un changement à tout observateur attaché à tout ou partie du tableau :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s">"test1"</span><span class="p">,</span><span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[0] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[1] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing arr[0]"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing arr[1]
arr changed
arr[0] changed
arr[1] changed
</code></pre></div></div>

<h3 id="dictionnaires">Dictionnaires</h3>

<p>Le même principe s’applique aux dictionnaires :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">:</span><span class="s">"test1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">:</span><span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['1'] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"2"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['2'] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing dict['1']"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing dict['2']
dict changed
dict['1'] changed
dict['2'] changed
</code></pre></div></div>

<h3 id="structures">Structures</h3>

<p>Idem pour les structures, pour lesquelles changer un membre change la valeur totale de celle-ci :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">TestValue</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">TestValue</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing value.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing value.str1
value changed
value.str1 changed
value.str2 changed
</code></pre></div></div>

<h2 id="étude-approfondie--sémantique-de-référence">Étude approfondie : sémantique de référence</h2>

<p>Pour les type avec une sémantique de référence, la notification de changement est envoyée dès lors que la référence change.
Par voie de conséquence, tous les accès aux propriétés des objets référencés reçoivent également la mise à jour :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref
ref changed
ref.str changed
</code></pre></div></div>

<p>Noter que, comme vu plus haut, le changement est déclenché même si concrètement aucune valeur ne change
(<code class="language-plaintext highlighter-rouge">ref.str</code> vaut toujours <code class="language-plaintext highlighter-rouge">"test"</code> avant et après, et on aurait le même résultat si on avait fait <code class="language-plaintext highlighter-rouge">test.ref = test.ref</code>).</p>

<h3 id="changements-dans-un-objet-par-référence">Changements dans un objet par référence</h3>

<p>Contrairement aux structures vues plus haut, par défaut, accéder en écriture à une propriété dans un objet par référence ne déclenche pas de changement :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
</code></pre></div></div>

<p>Pour que ce soit le cas il suffit de rendre la classe <code class="language-plaintext highlighter-rouge">@Observable</code> :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
ref.str changed
</code></pre></div></div>

<p>Noter que dans ce cas, contrairement à la structure, aucun changement n’est déclenché sur <code class="language-plaintext highlighter-rouge">ref</code>, car c’est la référence qui compte, et ici celle-ci n’est pas touchée.</p>

<h2 id="reduction-des-changements">Reduction des changements</h2>

<p>Lorsque plusieurs accès en écriture provoquent le même changement, un seul événement est déclenché :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="kt">Task</span> <span class="p">{</span> <span class="kd">@MainActor</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str1 and/or ref.str2 changed"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Original values"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new1"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new2"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original values
str1: test1
str2: test2
Changing ref.str1
Changing ref.str2
ref.str1 and/or ref.str2 changed
str1: new1
str2: new2
</code></pre></div></div>

<p>Cet exemple est un peu complexe.
Un exemple dans une app SwiftUI est plus parlant :</p>

<p><em>Ce code ne fonctionne pas dans une playground. Il faut créer une app.</em></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>  
            <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View update"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str1"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str1"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str2"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change both"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing both"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Résultat :</p>

<p><img src="/assets/2025-03-06-swift-observation/1.gif" alt="" /></p>

<p>Lorsqu’on clique sur <strong>Change both</strong>, nous remarquons qu’un seul <code class="language-plaintext highlighter-rouge">View update</code> est émis, même si les deux valeurs sont mises à jour simultanément. Cela témoigne d’une performance optimisée, où les vues ne se recalculent qu’une seule fois, indépendamment du nombre de modifications apportées à l’objet.</p>

<h2 id="changement-dun-objet-par-référence-exemple-dans-une-app-swiftui">Changement d’un objet par référence, exemple dans une app SwiftUI</h2>

<p>Si nous remplaçons un objet au lieu de modifier uniquement les propriétés changeantes, nous déclenchons un changement au niveau de l’objet, ce qui entraîne une mise à jour de toutes les vues qui dépendent de ses propriétés, même si ces dernières ne changent pas :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">View1</span><span class="p">()</span>
            <span class="kt">View2</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change ref"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">environment</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View1</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View1 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View2</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View2 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Résultat :</p>

<p><img src="/assets/2025-03-06-swift-observation/2.gif" alt="" /></p>

<p>En cliquant sur <strong>Change ref</strong>, nous constatons que les deux vues se mettent à jour, même si les données affichées n’ont pas changé. Pour optimiser les performances, il est donc préférable de ne modifier que les propriétés réellement modifiées.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Le framework Observation représente une avancée significative dans la gestion de la réactivité au sein des applications Swift. En offrant une granularité fine dans le suivi des changements, il permet d’optimiser les performances tout en simplifiant la gestion des dépendances. Les développeurs doivent cependant garder à l’esprit la nécessité de transitionner vers une sémantique de référence et de gérer judicieusement les accès en lecture et en écriture.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduit en 2023, le framework Observation vise à simplifier les mécanismes existant en matière de réactivité tout en améliorant les performances des applications.]]></summary></entry></feed>