<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-01T04:48:57-05:00</updated><id>/feed.xml</id><title type="html">Alexandre Bintz</title><subtitle>{&quot;en&quot;=&gt;&quot;Alexandre Bintz - Engineer and maker&quot;, &quot;fr&quot;=&gt;&quot;Alexandre Bintz - Ingénieur et maker&quot;}</subtitle><author><name>Alexandre Bintz</name></author><entry><title type="html">(fr) Photos</title><link href="/2025/04/04/photos_fr.html" rel="alternate" type="text/html" title="(fr) Photos" /><published>2025-04-04T02:52:01-05:00</published><updated>2025-04-04T02:52:01-05:00</updated><id>/2025/04/04/photos_fr</id><content type="html" xml:base="/2025/04/04/photos_fr.html"><![CDATA[<p>Voici quelques photos que j’ai prises. Plus sur ma page <a href="https://www.flickr.com/photos/189385048@N05/">my Flickr</a>.</p>

<p><a href="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg"><img src="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg"><img src="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg"><img src="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg"><img src="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg"><img src="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg"><img src="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg"><img src="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg" alt="" /></a></p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[Voici quelques photos que j’ai prises. Plus sur ma page my Flickr.]]></summary></entry><entry><title type="html">Photos</title><link href="/2025/04/04/photos_en.html" rel="alternate" type="text/html" title="Photos" /><published>2025-04-04T02:52:01-05:00</published><updated>2025-04-04T02:52:01-05:00</updated><id>/2025/04/04/photos_en</id><content type="html" xml:base="/2025/04/04/photos_en.html"><![CDATA[<p>Here are some pictures I took. You can see more on <a href="https://www.flickr.com/photos/189385048@N05/">my Flickr</a>.</p>

<p><a href="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg"><img src="/assets/2025-04-04-photos/203902881_1941499075999282_4032388649777417923_n.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg"><img src="/assets/2025-04-04-photos/50148054053_f65b320ff9_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg"><img src="/assets/2025-04-04-photos/50148804072_ac4c54c1a4_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg"><img src="/assets/2025-04-04-photos/50758854533_7614ef4d1b_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg"><img src="/assets/2025-04-04-photos/51750329257_71536a0d87_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg"><img src="/assets/2025-04-04-photos/51752269422_6f8d04b62d_o.jpg" alt="" /></a></p>

<p><a href="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg"><img src="/assets/2025-04-04-photos/EgRU79zVoAI3uLc.jpg" alt="" /></a></p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[Here are some pictures I took. You can see more on my Flickr.]]></summary></entry><entry><title type="html">(fr) Reconnaissance vocale dans une app SwiftUI</title><link href="/2025/03/14/swiftui-speech_fr.html" rel="alternate" type="text/html" title="(fr) Reconnaissance vocale dans une app SwiftUI" /><published>2025-03-14T04:23:06-05:00</published><updated>2025-03-14T04:23:06-05:00</updated><id>/2025/03/14/swiftui-speech_fr</id><content type="html" xml:base="/2025/03/14/swiftui-speech_fr.html"><![CDATA[<p>Dans un précédent article, nous avons vu l’accès au microphone dans une application SwiftUI sur macOS.
Dans cet article nous allons ajouter la reconnaissance vocale avec le framework <a href="https://developer.apple.com/documentation/speech">Speech</a>.</p>

<h2 id="vérifier-la-permission">Vérifier la permission</h2>

<p>Comme pour l’accès au micro, l’utilisateur•ice doit autoriser notre app à utiliser la reconnaissance vocale.
Le principe est similaire à la permission micro,
les cas possibles sont: autorisé, refusé/restreint ou indéterminé.</p>

<p>Comme pour le micro, je commence par ajouter dans le contrôleur un un booléen optionnel qui reflètera l’état de l’autorisation d’accès à la reconnaissance vocale, j’affiche la valeur de l’autorisation dans la vue, et je modifie la propriété <code class="language-plaintext highlighter-rouge">ready</code> pour prendre en compte la reconnaissance vocale.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition authorisation"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La fonction système qui indique l’autorisation de la reconnaissance vocale est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.authorizationStatus()</code>.
Comme pour le micro, je crée une propriété calculée dans le contrôleur pour encapsuler l’appel à la fonction système, et une fonction qui met à jour la propriété observable en fonction de la valeur brute de la permission, et je fais une première mise à jour dans l’initialiseur.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Speech</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorisationStatus</span><span class="p">:</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">speechRecognitionAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">speechRecognitionAuthorisationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="demander-la-permission">Demander la permission</h2>

<p>La fonction système pour demander la permission est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.requestAuthorization(:)</code>.
Elle renvoie la valeur de l’autorisation dans une closure.
Comme pour le micro, je crée une fonction qui encapsule l’appel à la fonction système et renvoie la valeur de l’autorisation.
J’utilise <code class="language-plaintext highlighter-rouge">withCheckedContinuation(:)</code> pour utiliser <code class="language-plaintext highlighter-rouge">async/await</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">requestSpeechRecognitionAuthorisation</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">withCheckedContinuation</span> <span class="p">{</span> <span class="n">continuation</span> <span class="k">in</span>
            <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="n">requestAuthorization</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">updateSpeechRecognitionAuthorisationStatus</span><span class="p">()</span>
                <span class="n">continuation</span><span class="o">.</span><span class="nf">resume</span><span class="p">(</span><span class="nv">returning</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAuthorisationStatus</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Comme pour le micro, on peut appeler la méthode <code class="language-plaintext highlighter-rouge">requestSpeechRecognitionAuthorisation()</code> de manière systématique pour récupérer l’état de l’autorisation, la question n’est posée à l’utilisateur que si nécessaire.</p>

<p>J’appelle cette fonction dans <code class="language-plaintext highlighter-rouge">start()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">let</span> <span class="nv">speechRecognitonStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestSpeechRecognitionAuthorisation</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">speechRecognitonStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition not authorized (</span><span class="se">\(</span><span class="n">speechRecognitonStatus</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La commande suivante permet de réinitialiser la demande de permission, utile en développement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset SpeechRecognition &lt;bundle.id&gt;
</code></pre></div></div>

<h2 id="initialisation-et-vérification-de-la-disponibilité">Initialisation et vérification de la disponibilité</h2>

<p>Tout est désormais prêt pour démarrer la reconnaissance vocale.
La classe principale est <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>.
Dans le contrôleur j’ajoute une propriété qui permettra de stocker une instance de cette classe.
Bien que le contrôleur pourra démarrer et arrêter la reconnaissance vocale à loisir,
une seule instance de <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> est nécessaire.</p>

<p>Par défaut la reconnaissance vocale reconnait la langue configurée sur l’appareil,
mais il est possible de passer une locale spécifique.
Ici je force la langue française dans sa variante de France.</p>

<p>La reconnaissance vocale peut ne pas être disponible sur un appareil donné à un instant donné,
notamment par rapport à l’état de la connexion Internet.
La disponibilité en temps réel est donnée par la fonction <code class="language-plaintext highlighter-rouge">SFSpeechRecognizerDelegate.speechRecognizer(_:availabilityDidChange:)</code>.
J’implémente cette fonction sur le contrôleur et configure le <code class="language-plaintext highlighter-rouge">delegate</code> de l’objet <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>.
À noter qu’il existe aussi la propriété <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.isAvailable</code> qui permet d’interroger directement la disponibilité.</p>

<p>Pour une expérience utilisateur optimale, il est préférable d’ajuster l’affichage et le comportement de l’application selon la possibilité d’utiliser ou non la reconnaissance vocale dès le démarrage.
Si on attend que l’utilisateur•ice essaie d’accéder aux fonctionnalités associées pour le vérifier,
on risque de créer de la frustration si ces fonctionnalités s’avèrent indisponibles.
J’initialise donc l’instance <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> dans l’initialiseur.</p>

<p>Dans la vue j’affiche la disponibilité de la reconnaissance vocale, et je modifie <code class="language-plaintext highlighter-rouge">ready</code> pour prendre en compte cette nouvelle donnée.
Dans ce cas, on n’autorise que si on est sûr que la fonctionnalité est disponible.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition availability"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">available</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">available</span> <span class="p">?</span> <span class="s">"Available"</span> <span class="p">:</span> <span class="s">"Unavailable"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">!=</span> <span class="kc">true</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">SFSpeechRecognizerDelegate</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">speechRecognitionAvailable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="c1">// ...</span>
        <span class="c1">// init speech recognizer with forced locale</span>
        <span class="k">let</span> <span class="nv">locale</span> <span class="o">=</span> <span class="kt">Locale</span><span class="p">(</span><span class="nv">identifier</span><span class="p">:</span> <span class="s">"fr_FR"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">recognizer</span> <span class="o">=</span> <span class="kt">SFSpeechRecognizer</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="n">locale</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Unable to create a SFSpeechRecognizer object with locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">speechRecognizer</span> <span class="o">=</span> <span class="n">recognizer</span>
        <span class="n">speechRecognizer</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition ready, using locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">speechRecognizer</span><span class="p">(</span><span class="n">_</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="p">,</span> <span class="n">availabilityDidChange</span> <span class="nv">available</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">=</span> <span class="n">available</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="démarrage-de-la-reconnaissance-et-traitement-des-résultats">Démarrage de la reconnaissance et traitement des résultats</h2>

<p>On peut maintenant lancer la reconnaissance vocale à proprement parler lorsque l’utilisateur•ice clique sur <strong>Start</strong>.
Je commence par créer des fonctions <code class="language-plaintext highlighter-rouge">startRecognition()</code> et <code class="language-plaintext highlighter-rouge">stopRecognition()</code>, que j’appelle respectivement dans <code class="language-plaintext highlighter-rouge">start()</code> et <code class="language-plaintext highlighter-rouge">stop()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ... (check permissions)</span>
        <span class="c1">// ... (start audio)</span>
        
        <span class="nf">startRecognition</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition active"</span><span class="p">)</span>
        
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">stopRecognition</span><span class="p">()</span>
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pour une session de reconnaissance nous avons besoin d’une instance de <code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code> et <code class="language-plaintext highlighter-rouge">SFSpeechRecognitionTask</code>.
J’ajoute deux propriétés correspondantes dans le contrôleur.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionRequest</span><span class="p">:</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="o">!</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionTask</span><span class="p">:</span> <span class="kt">SFSpeechRecognitionTask</span><span class="o">!</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On commence par initialiser une requête.
Ensuite il faut alimenter la requête avec les données audio issues du micro.
Pour cela on utilise le “tap” mis en place précédement.
Enfin, on lance une tâche de reconnaissance vocale à partir de la requête.
Les résultats sont envoyés à une closure au fur et à mesure que la personne parle.
<code class="language-plaintext highlighter-rouge">result.bestTranscription</code> contient la transcription des paroles prononcées.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">recognitionRequest</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="n">speechRecognizer</span><span class="o">.</span><span class="nf">recognitionTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">recognitionRequest</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">result</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">recognizedText</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">bestTranscription</span><span class="o">.</span><span class="n">formattedString</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pour l’arrêt de la reconnaissance, on peut appeler <code class="language-plaintext highlighter-rouge">recognitionTask.finish()</code> et <code class="language-plaintext highlighter-rouge">recognitionRequest.endAudio()</code>, et enlever le tap.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="n">recognitionRequest</span><span class="p">?</span><span class="o">.</span><span class="nf">endAudio</span><span class="p">()</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">recognitionTask</span><span class="p">?</span><span class="o">.</span><span class="nf">finish</span><span class="p">()</span>
        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Et voilà, tout est fonctionnel.</p>

<p><img src="/assets/2025-03-14-swiftui-speech/1.gif" alt="" /></p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[Dans un précédent article, nous avons vu l’accès au microphone dans une application SwiftUI sur macOS. Dans cet article nous allons ajouter la reconnaissance vocale avec le framework Speech.]]></summary></entry><entry><title type="html">Speech Recognition in a SwiftUI App</title><link href="/2025/03/14/swiftui-speech_en.html" rel="alternate" type="text/html" title="Speech Recognition in a SwiftUI App" /><published>2025-03-14T04:23:06-05:00</published><updated>2025-03-14T04:23:06-05:00</updated><id>/2025/03/14/swiftui-speech_en</id><content type="html" xml:base="/2025/03/14/swiftui-speech_en.html"><![CDATA[<p>In a previous article, we explored microphone access in a SwiftUI application on macOS. In this article, we will add speech recognition using the <a href="https://developer.apple.com/documentation/speech">Speech</a> framework.</p>

<h2 id="checking-permissions">Checking permissions</h2>

<p>As with microphone access, the user must grant our app permission to use speech recognition. The principle is similar to microphone permission, and the possible statuses are: granted, denied/restricted, or undetermined.</p>

<p>Like with the microphone, I start by adding an optional boolean in the controller to reflect the status of speech recognition access permission, display the authorization value in the view, and modify the <code class="language-plaintext highlighter-rouge">ready</code> property to account for speech recognition.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition authorization"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The system function that indicates speech recognition authorization is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.authorizationStatus()</code>.
Similar to the microphone, I create a computed property in the controller to encapsulate the system function call, along with a function that updates the observable property based on the raw permission value, and I perform an initial update in the initializer.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Speech</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>   
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">speechRecognitionAuthorizationStatus</span><span class="p">:</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">speechRecognitionAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">speechRecognitionAuthorizationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="requesting-permission">Requesting permission</h2>

<p>The system function to request permission is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.requestAuthorization(:)</code>. It returns the authorization value in a closure. Similar to the microphone, I create a function that encapsulates the system function call and returns the authorization value. I use <code class="language-plaintext highlighter-rouge">withCheckedContinuation(:)</code> to utilize <code class="language-plaintext highlighter-rouge">async/await</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">requestSpeechRecognitionAuthorization</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">SFSpeechRecognizerAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="n">withCheckedContinuation</span> <span class="p">{</span> <span class="n">continuation</span> <span class="k">in</span>
            <span class="kt">SFSpeechRecognizer</span><span class="o">.</span><span class="n">requestAuthorization</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="o">.</span><span class="nf">updateSpeechRecognitionAuthorizationStatus</span><span class="p">()</span>
                <span class="n">continuation</span><span class="o">.</span><span class="nf">resume</span><span class="p">(</span><span class="nv">returning</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAuthorizationStatus</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As with the microphone, the <code class="language-plaintext highlighter-rouge">requestSpeechRecognitionAuthorization()</code> method can be called systematically to retrieve the authorization state, and the user is prompted only if necessary.</p>

<p>I call this function in <code class="language-plaintext highlighter-rouge">start()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">let</span> <span class="nv">speechRecognitionStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestSpeechRecognitionAuthorization</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">speechRecognitionStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition not authorized (</span><span class="se">\(</span><span class="n">speechRecognitionStatus</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following command resets the permission request, which is useful during development.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset SpeechRecognition &lt;bundle.id&gt;
</code></pre></div></div>

<h2 id="initialization-and-availability-check">Initialization and availability check</h2>

<p>Everything is now ready to start speech recognition. The main class is <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code>. In the controller, I add a property to store an instance of this class. Although the controller can start and stop speech recognition at will, only one instance of <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> is needed.</p>

<p>By default, speech recognition recognizes the language configured on the device, but it is possible to specify a specific locale. Here, I force the French language in its France variant.</p>

<p>Speech recognition may not be available on a given device at a certain time, particularly regarding the state of the Internet connection. Real-time availability is provided by the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizerDelegate.speechRecognizer(_:availabilityDidChange:)</code> function. I implement this function in the controller and configure the <code class="language-plaintext highlighter-rouge">delegate</code> of the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> object. Note that there is also the property <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer.isAvailable</code> that allows direct querying of availability.</p>

<p>For an optimal user experience, it is best to adjust the display and behavior of the application based on the availability of speech recognition from the start. If we wait for the user to try accessing related features to check for availability, it may lead to frustration if these features turn out to be unavailable. Thus, I initialize the <code class="language-plaintext highlighter-rouge">SFSpeechRecognizer</code> instance in the initializer.</p>

<p>In the view, I display the availability of speech recognition and modify <code class="language-plaintext highlighter-rouge">ready</code> to account for this new information. In this case, we only allow access if we are sure the functionality is available.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">,</span> <span class="nv">verticalSpacing</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Speech recognition availability"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">available</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">available</span> <span class="p">?</span> <span class="s">"Available"</span> <span class="p">:</span> <span class="s">"Unavailable"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">!=</span> <span class="kc">true</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">SFSpeechRecognizerDelegate</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">speechRecognitionAvailable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="c1">// ...</span>
        <span class="c1">// init speech recognizer with forced locale</span>
        <span class="k">let</span> <span class="nv">locale</span> <span class="o">=</span> <span class="kt">Locale</span><span class="p">(</span><span class="nv">identifier</span><span class="p">:</span> <span class="s">"fr_FR"</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">recognizer</span> <span class="o">=</span> <span class="kt">SFSpeechRecognizer</span><span class="p">(</span><span class="nv">locale</span><span class="p">:</span> <span class="n">locale</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Unable to create a SFSpeechRecognizer object with locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">speechRecognizer</span> <span class="o">=</span> <span class="n">recognizer</span>
        <span class="n">speechRecognizer</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Speech recognition ready, using locale </span><span class="se">\(</span><span class="n">locale</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">speechRecognizer</span><span class="p">(</span><span class="n">_</span> <span class="nv">speechRecognizer</span><span class="p">:</span> <span class="kt">SFSpeechRecognizer</span><span class="p">,</span> <span class="n">availabilityDidChange</span> <span class="nv">available</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">speechRecognitionAvailable</span> <span class="o">=</span> <span class="n">available</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="starting-recognition-and-processing-results">Starting recognition and processing results</h2>

<p>We can now start speech recognition when the user clicks <strong>Start</strong>. I begin by creating <code class="language-plaintext highlighter-rouge">startRecognition()</code> and <code class="language-plaintext highlighter-rouge">stopRecognition()</code> functions, which I call respectively in <code class="language-plaintext highlighter-rouge">start()</code> and <code class="language-plaintext highlighter-rouge">stop()</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ... (check permissions)</span>
        <span class="c1">// ... (start audio)</span>
        
        <span class="nf">startRecognition</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition active"</span><span class="p">)</span>
        
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">stopRecognition</span><span class="p">()</span>
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For a recognition session, we need an instance of <code class="language-plaintext highlighter-rouge">SFSpeechAudioBufferRecognitionRequest</code> and <code class="language-plaintext highlighter-rouge">SFSpeechRecognitionTask</code>. I add two corresponding properties in the controller.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionRequest</span><span class="p">:</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="o">!</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">recognitionTask</span><span class="p">:</span> <span class="kt">SFSpeechRecognitionTask</span><span class="o">!</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We start by initializing a request. Next, we need to feed the request with audio data from the microphone. For this, we use the “tap” set up previously. Finally, we launch a speech recognition task from the request. The results are sent to a closure as the person speaks, and <code class="language-plaintext highlighter-rouge">result.bestTranscription</code> contains the transcription of the spoken words.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRecognition</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kt">SFSpeechAudioBufferRecognitionRequest</span><span class="p">()</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">recognitionRequest</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="n">speechRecognizer</span><span class="o">.</span><span class="nf">recognitionTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">recognitionRequest</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Recognition error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">result</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">recognizedText</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">bestTranscription</span><span class="o">.</span><span class="n">formattedString</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To stop recognition, we can call <code class="language-plaintext highlighter-rouge">recognitionTask.finish()</code> and <code class="language-plaintext highlighter-rouge">recognitionRequest.endAudio()</code>, and remove the tap.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">stopRecognition</span><span class="p">()</span> <span class="p">{</span>
        
        <span class="n">recognitionRequest</span><span class="p">?</span><span class="o">.</span><span class="nf">endAudio</span><span class="p">()</span>
        <span class="n">recognitionRequest</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">recognitionTask</span><span class="p">?</span><span class="o">.</span><span class="nf">finish</span><span class="p">()</span>
        <span class="n">recognitionTask</span> <span class="o">=</span> <span class="kc">nil</span>
        
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And there, everything is working.</p>

<p><img src="/assets/2025-03-14-swiftui-speech/1.gif" alt="" /></p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[In a previous article, we explored microphone access in a SwiftUI application on macOS. In this article, we will add speech recognition using the Speech framework.]]></summary></entry><entry><title type="html">Swift Observation: in-depth analysis</title><link href="/2025/03/06/swift-observation_en.html" rel="alternate" type="text/html" title="Swift Observation: in-depth analysis" /><published>2025-03-06T04:23:15-06:00</published><updated>2025-03-06T04:23:15-06:00</updated><id>/2025/03/06/swift-observation_en</id><content type="html" xml:base="/2025/03/06/swift-observation_en.html"><![CDATA[<p>Introduced in 2023, the <a href="https://developer.apple.com/documentation/observation">Observation</a> framework aims to simplify existing reactive mechanisms while improving application performance.</p>

<p>This new approach relies on the automatic tracking of data accesses via the <a href="https://developer.apple.com/documentation/observation/withobservationtracking(_:onchange:)"><code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code></a> method.</p>

<p>In this article, we will experiment with this method to understand how it works and its limitations.</p>

<h2 id="general-principles">General principles</h2>

<p>The Observation framework is based on the use of reference types. The <a href="https://developer.apple.com/documentation/observation/observable()"><code class="language-plaintext highlighter-rouge">@Observable</code></a> macro can only be applied to classes, not structures. Therefore, applications relying on value semantics will first need to transition to reference semantics, a task that can be complex.</p>

<p>A class annotated with <code class="language-plaintext highlighter-rouge">@Observable</code> detects and records accesses to its properties. Only accesses to stored properties are taken into account. However, access can be indirect, for example, through a function or a computed property. If a chain of calls ultimately results in access to a stored property, Observation detects it.</p>

<p>Both read and write accesses are detected. Read accesses are used to identify dependencies, while write accesses send change notifications.</p>

<h2 id="a-simple-example">A simple example</h2>

<p>Note: All code presented works as is in a playground.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>In this example, we declare an observable class with a simple property and create an instance of it. We access the object’s property in the <code class="language-plaintext highlighter-rouge">apply</code> block of <code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code>. The read access is detected and recorded. Finally, by modifying the property’s value from outside, the write access is also detected, resulting in the invocation of the <code class="language-plaintext highlighter-rouge">onChange</code> block.</p>

<h2 id="observation-is-attached-with-read-access">Observation is attached with read access</h2>

<p>If we modify the code to perform a write access instead of a read access in the <code class="language-plaintext highlighter-rouge">apply</code> block, we find that the change is not detected:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"write"</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
</code></pre></div></div>

<p>It turns out that only read accesses connect the observation. This makes sense: a component that only writes does not need to be informed of value changes.</p>

<h2 id="the-write-access-always-triggers-the-notification">The write access always triggers the notification</h2>

<p>If we write to the property by passing a value identical to the existing value, the change notification is still sent:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"test"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Write accesses always trigger a change event, even if the value does not actually change. If the developer wants to trigger the event only if the value actually changes, it’s up to them to ensure that they write to the variable only if the new value is different.</p>

<h2 id="only-read-properties-are-observed">Only read properties are observed</h2>

<p>By adding a second property, we find that only a change to the property read in <code class="language-plaintext highlighter-rouge">apply</code> triggers a change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str2
str2 changed
</code></pre></div></div>

<p>Only the blocks attached to the properties that change are called. This represents a major improvement over previous techniques, where the object as a whole was observed. This increased granularity can enhance performance by limiting updates to the parts that are actually affected.</p>

<h2 id="in-depth-study-value-semantics">In-depth study: value semantics</h2>

<p>For types with value semantics, which include all primitive types, as well as arrays and dictionaries, and also structures, the change notification is sent as soon as the value changes.</p>

<p>We have already seen examples earlier for primitive types like <code class="language-plaintext highlighter-rouge">String</code>. The case of arrays, dictionaries, and structures is interesting, albeit entirely logical.</p>

<h3 id="arrays">Arrays</h3>

<p>In the case of an array, changing a value in the array changes the overall value of the array, thus sending a change to any observer attached to all or part of the array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s">"test1"</span><span class="p">,</span> <span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[0] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[1] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing arr[0]"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing arr[1]
arr changed
arr[0] changed
arr[1] changed
</code></pre></div></div>

<h3 id="dictionaries">Dictionaries</h3>

<p>The same principle applies to dictionaries:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">:</span> <span class="s">"test1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">:</span> <span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['1'] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"2"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['2'] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing dict['1']"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing dict['2']
dict changed
dict['1'] changed
dict['2'] changed
</code></pre></div></div>

<h3 id="structures">Structures</h3>

<p>Similarly for structures, changing a member changes its total value:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">TestValue</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">TestValue</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing value.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing value.str1
value changed
value.str1 changed
value.str2 changed
</code></pre></div></div>

<h2 id="in-depth-study-reference-semantics">In-depth study: reference semantics</h2>

<p>For types with reference semantics, the change notification is sent as soon as the reference changes. Consequently, all accesses to the properties of the referenced objects also receive the update:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref
ref changed
ref.str changed
</code></pre></div></div>

<p>Note that, as seen earlier, the change is triggered even if no value actually changes (<code class="language-plaintext highlighter-rouge">ref.str</code> remains <code class="language-plaintext highlighter-rouge">"test"</code> before and after, and we would have the same result if we had done <code class="language-plaintext highlighter-rouge">test.ref = test.ref</code>).</p>

<h3 id="changes-in-a-referenced-object">Changes in a referenced object</h3>

<p>Unlike the structures seen earlier, by default, writing to a property in a reference object does not trigger a change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
</code></pre></div></div>

<p>To ensure that this is the case, we simply need to make the class <code class="language-plaintext highlighter-rouge">@Observable</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
ref.str changed
</code></pre></div></div>

<p>Note that in this case, unlike the structure, no change is triggered on <code class="language-plaintext highlighter-rouge">ref</code>, because it is the reference that matters, and here it is not affected.</p>

<h2 id="reduction-of-changes">Reduction of changes</h2>

<p>When multiple write accesses cause the same change, only one event is triggered:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="kt">Task</span> <span class="p">{</span> <span class="kd">@MainActor</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str1 and/or ref.str2 changed"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Original values"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new1"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new2"</span>
</code></pre></div></div>

<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original values
str1: test1
str2: test2
Changing ref.str1
Changing ref.str2
ref.str1 and/or ref.str2 changed
str1: new1
str2: new2
</code></pre></div></div>

<p>This example is somewhat complex. An example in a SwiftUI app is more illustrative:</p>

<p><em>This code does not work in a playground. You need to create an app.</em></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>  
            <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View update"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str1"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str1"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str2"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change both"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing both"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Result:</p>

<p><img src="/assets/2025-03-06-swift-observation/1.gif" alt="" /></p>

<p>When we click on <strong>Change both</strong>, we notice that only one <code class="language-plaintext highlighter-rouge">View update</code> is emitted, even though both values are updated simultaneously. This indicates optimized performance, where views are recalculated only once, regardless of the number of modifications made to the object.</p>

<h2 id="changing-a-referenced-object-example-in-a-swiftui-app">Changing a referenced object, example in a SwiftUI app</h2>

<p>If we replace an object instead of modifying only the changing properties, we trigger a change at the object level, causing an update of all views that depend on its properties, even if those properties do not change:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">View1</span><span class="p">()</span>
            <span class="kt">View2</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change ref"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">environment</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View1</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View1 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View2</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View2 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Result:</p>

<p><img src="/assets/2025-03-06-swift-observation/2.gif" alt="" /></p>

<p>When clicking on <strong>Change ref</strong>, we find that both views update, even if the displayed data did not change. To optimize performance, it is therefore preferable to modify only the properties that have actually changed.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Observation framework represents a significant advancement in managing reactivity within Swift applications. By offering fine-grained change tracking, it optimizes performance while simplifying dependency management. Developers must, however, keep in mind the need to transition to reference semantics and to manage read and write accesses judiciously.</p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[Introduced in 2023, the Observation framework aims to simplify existing reactive mechanisms while improving application performance.]]></summary></entry><entry><title type="html">(fr) Swift Observation: étude approfondie</title><link href="/2025/03/06/swift-observation_fr.html" rel="alternate" type="text/html" title="(fr) Swift Observation: étude approfondie" /><published>2025-03-06T04:23:15-06:00</published><updated>2025-03-06T04:23:15-06:00</updated><id>/2025/03/06/swift-observation_fr</id><content type="html" xml:base="/2025/03/06/swift-observation_fr.html"><![CDATA[<p>Introduit en 2023, le framework <a href="https://developer.apple.com/documentation/observation">Observation</a>
vise à simplifier les mécanismes existant en matière de réactivité tout en améliorant les performances des applications.</p>

<p>Cette nouvelle approche repose sur le tracking automatique des accès aux données
via la méthode <a href="https://developer.apple.com/documentation/observation/withobservationtracking(_:onchange:)"><code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code></a>.</p>

<p>Dans cet article nous allons jouer avec cette méthode pour en comprendre le fonctionnement et les limitations.</p>

<h2 id="fonctionnement-général">Fonctionnement général</h2>

<p>Le framework Observation repose sur l’utilisation de types de référence. La macro <a href="https://developer.apple.com/documentation/observation/observable()"><code class="language-plaintext highlighter-rouge">@Observable</code></a> ne peut être appliquée qu’aux classes, excluant ainsi les structures. Par conséquent, les applications s’appuyant sur une sémantique de valeur devront d’abord effectuer une transition vers une sémantique de référence, une tâche qui peut s’avérer complexe selon les contextes.</p>

<p>Une classe annotée avec <code class="language-plaintext highlighter-rouge">@Observable</code> détecte et mémorise les accès à ses propriétés.
Seuls les accès aux propriétés stockées sont pris en compte.
Cependant, l’accès peut-être indirect, par exemple via une fonction ou une propriété calculée.
Si une chaine d’appels résulte <em>in fine</em> en en accès à une propriété stockée, Observation le détecte.</p>

<p>Les accès en lecture et écriture sont détectés.
Les accès en lecture servent à identifier les dépendances,
les accès en écriture à envoyer les notifications de changement.</p>

<h2 id="un-exemple-simple">Un exemple simple</h2>

<p>Remarque : Tous les codes présentés fonctionnent tel quel dans une <em>playground</em>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Dans cet exemple, nous déclarons une classe observable avec une propriété simple et créons une instance de celle-ci. Nous accédons à la propriété de l’objet dans le bloc <code class="language-plaintext highlighter-rouge">apply</code> de <code class="language-plaintext highlighter-rouge">withObservationTracking(_:onChange:)</code>.
L’accès en lecture est détecté et mémorisé. Enfin, en modifiant la valeur de la propriété à l’extérieur, l’accès en écriture est également détecté, entraînant l’appel du bloc <code class="language-plaintext highlighter-rouge">onChange</code>.</p>

<h2 id="cest-laccès-en-lecture-qui-attache-lobservation">C’est l’accès en lecture qui attache l’observation</h2>

<p>Si nous modifions le code pour effectuer un accès en écriture plutôt qu’en lecture dans le bloc <code class="language-plaintext highlighter-rouge">apply</code>, nous constatons que le changement n’est pas détecté :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"write"</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
</code></pre></div></div>

<p>Il s’avère donc que seuls les accès en lecture permettent de connecter l’observation. Cette logique est cohérente : un composant qui ne fait qu’écrire n’a pas besoin d’être informé des changements de valeur.</p>

<h2 id="laccès-en-écriture-déclenche-toujours-la-notification">L’accès en écriture déclenche <em>toujours</em> la notification</h2>

<p>Si nous accédons en écriture à la propriété en passant une valeur identique à la valeur existante, la notification de changement est toujours envoyée :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"test"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str
str changed 
</code></pre></div></div>

<p>Les accès en écriture déclenchent donc toujours un événement de changement, même si la valeur ne change pas dans la pratique. Si nous voulons déclencher l’événement seulement si la valeur change réellement, charge à nous de nous assurer d’écrire la variable seulement si la nouvelle valeur est différente.</p>

<h2 id="seules-les-propriétées-lues-sont-observées">Seules les propriétées lues sont observées</h2>

<p>En ajoutant une seconde propriété, nous constatons que seul un changement à la propriété lue dans <code class="language-plaintext highlighter-rouge">apply</code> déclenche un changement :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing str2
str2 changed
</code></pre></div></div>

<p>Seuls les blocs attachés aux propriétés qui changent sont appelés. Cela constitue une amélioration majeure par rapport aux techniques précédentes, où l’objet dans son ensemble était observé. Cette granularité accrue peut améliorer les performances en limitant les mises à jour aux parties réellement concernées.</p>

<h2 id="étude-approfondie--sémantique-de-valeur">Étude approfondie : sémantique de valeur</h2>

<p>Pour les types avec une sémantique de valeur, ce qui comprend notamment tous types les primitifs, ainsi que les tableaux et les dictionnaires, mais aussi les structures, la notification de changement est envoyée dès que la valeur change.</p>

<p>Nous avons déjà vu des exemples plus haut pour les types primitifs comme <code class="language-plaintext highlighter-rouge">String</code>.
Le cas des tableaux, dictionnaires et structures et intéressant, bien que tout à fait logique.</p>

<h3 id="tableaux">Tableaux</h3>

<p>Dans le cas d’un tableau, changer une valeur dans le tableau change la valeur totale du tableau, et envoie donc un changement à tout observateur attaché à tout ou partie du tableau :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s">"test1"</span><span class="p">,</span><span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[0] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"arr[1] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing arr[0]"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing arr[1]
arr changed
arr[0] changed
arr[1] changed
</code></pre></div></div>

<h3 id="dictionnaires">Dictionnaires</h3>

<p>Le même principe s’applique aux dictionnaires :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dict</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">:</span><span class="s">"test1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">:</span><span class="s">"test2"</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['1'] changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"2"</span><span class="p">]</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"dict['2'] changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing dict['1']"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">"1"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing dict['2']
dict changed
dict['1'] changed
dict['2'] changed
</code></pre></div></div>

<h3 id="structures">Structures</h3>

<p>Idem pour les structures, pour lesquelles changer un membre change la valeur totale de celle-ci :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">TestValue</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">TestValue</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str1 changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value.str2 changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing value.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing value.str1
value changed
value.str1 changed
value.str2 changed
</code></pre></div></div>

<h2 id="étude-approfondie--sémantique-de-référence">Étude approfondie : sémantique de référence</h2>

<p>Pour les type avec une sémantique de référence, la notification de changement est envoyée dès lors que la référence change.
Par voie de conséquence, tous les accès aux propriétés des objets référencés reçoivent également la mise à jour :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref
ref changed
ref.str changed
</code></pre></div></div>

<p>Noter que, comme vu plus haut, le changement est déclenché même si concrètement aucune valeur ne change
(<code class="language-plaintext highlighter-rouge">ref.str</code> vaut toujours <code class="language-plaintext highlighter-rouge">"test"</code> avant et après, et on aurait le même résultat si on avait fait <code class="language-plaintext highlighter-rouge">test.ref = test.ref</code>).</p>

<h3 id="changements-dans-un-objet-par-référence">Changements dans un objet par référence</h3>

<p>Contrairement aux structures vues plus haut, par défaut, accéder en écriture à une propriété dans un objet par référence ne déclenche pas de changement :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
</code></pre></div></div>

<p>Pour que ce soit le cas il suffit de rendre la classe <code class="language-plaintext highlighter-rouge">@Observable</code> :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"test"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref changed"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str changed"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">"new"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Changing ref.str
ref.str changed
</code></pre></div></div>

<p>Noter que dans ce cas, contrairement à la structure, aucun changement n’est déclenché sur <code class="language-plaintext highlighter-rouge">ref</code>, car c’est la référence qui compte, et ici celle-ci n’est pas touchée.</p>

<h2 id="reduction-des-changements">Reduction des changements</h2>

<p>Lorsque plusieurs accès en écriture provoquent le même changement, un seul événement est déclenché :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>

<span class="n">withObservationTracking</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span>
<span class="p">}</span> <span class="nv">onChange</span><span class="p">:</span> <span class="p">{</span>
    <span class="kt">Task</span> <span class="p">{</span> <span class="kd">@MainActor</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"ref.str1 and/or ref.str2 changed"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Original values"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str1: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"str2: </span><span class="se">\(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str1"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"new1"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Changing ref.str2"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"new2"</span>
</code></pre></div></div>

<p>Résultat :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original values
str1: test1
str2: test2
Changing ref.str1
Changing ref.str2
ref.str1 and/or ref.str2 changed
str1: new1
str2: new2
</code></pre></div></div>

<p>Cet exemple est un peu complexe.
Un exemple dans une app SwiftUI est plus parlant :</p>

<p><em>Ce code ne fonctionne pas dans une playground. Il faut créer une app.</em></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>  
            <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View update"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str1"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str1"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change str2"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing str2"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change both"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Changing both"</span><span class="p">)</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
                <span class="n">test</span><span class="o">.</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Résultat :</p>

<p><img src="/assets/2025-03-06-swift-observation/1.gif" alt="" /></p>

<p>Lorsqu’on clique sur <strong>Change both</strong>, nous remarquons qu’un seul <code class="language-plaintext highlighter-rouge">View update</code> est émis, même si les deux valeurs sont mises à jour simultanément. Cela témoigne d’une performance optimisée, où les vues ne se recalculent qu’une seule fois, indépendamment du nombre de modifications apportées à l’objet.</p>

<h2 id="changement-dun-objet-par-référence-exemple-dans-une-app-swiftui">Changement d’un objet par référence, exemple dans une app SwiftUI</h2>

<p>Si nous remplaçons un objet au lieu de modifier uniquement les propriétés changeantes, nous déclenchons un changement au niveau de l’objet, ce qui entraîne une mise à jour de toutes les vues qui dépendent de ses propriétés, même si ces dernières ne changent pas :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">ref</span> <span class="o">=</span> <span class="kt">TestRef</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">TestRef</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">str1</span> <span class="o">=</span> <span class="s">"test1"</span>
    <span class="k">var</span> <span class="nv">str2</span> <span class="o">=</span> <span class="s">"test2"</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">TestApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">TestClass</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">View1</span><span class="p">()</span>
            <span class="kt">View2</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"Change ref"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">test</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">ref</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">environment</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View1</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View1 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">View2</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Environment</span><span class="p">(</span><span class="kt">TestClass</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">test</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">print</span><span class="p">(</span><span class="s">"View2 update"</span><span class="p">)</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">str2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Résultat :</p>

<p><img src="/assets/2025-03-06-swift-observation/2.gif" alt="" /></p>

<p>En cliquant sur <strong>Change ref</strong>, nous constatons que les deux vues se mettent à jour, même si les données affichées n’ont pas changé. Pour optimiser les performances, il est donc préférable de ne modifier que les propriétés réellement modifiées.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Le framework Observation représente une avancée significative dans la gestion de la réactivité au sein des applications Swift. En offrant une granularité fine dans le suivi des changements, il permet d’optimiser les performances tout en simplifiant la gestion des dépendances. Les développeurs doivent cependant garder à l’esprit la nécessité de transitionner vers une sémantique de référence et de gérer judicieusement les accès en lecture et en écriture.</p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[Introduit en 2023, le framework Observation vise à simplifier les mécanismes existant en matière de réactivité tout en améliorant les performances des applications.]]></summary></entry><entry><title type="html">(fr) Accès au micro dans une app SwiftUI</title><link href="/2025/02/28/swiftui-microphone_fr.html" rel="alternate" type="text/html" title="(fr) Accès au micro dans une app SwiftUI" /><published>2025-02-28T04:02:15-06:00</published><updated>2025-02-28T04:02:15-06:00</updated><id>/2025/02/28/swiftui-microphone_fr</id><content type="html" xml:base="/2025/02/28/swiftui-microphone_fr.html"><![CDATA[<p>J’ai une activité de vente en ligne de pièces de LEGO sur la plateforme BrickLink,
et je développe une application mac en SwiftUI pour m’aider à gérer mes ventes.</p>

<p>Pour le module d’aide au picking, j’ai imaginé une fonctionnalité mains libre basée sur des commandes vocales.
Dans cette optique, j’ai commencé par expérimenter avec le module de reconnaissance vocale d’Apple.
Mais au préalable, il faut accéder aux données audio du micro.</p>

<p>Dans cet article je reviens sur comment j’ai implémenté l’accès au micro dans une application Swift UI.</p>

<h2 id="préparation">Préparation</h2>

<p>Pour que l’app puisse avoir accès au micro, il faut cocher <strong>Audio Input</strong> dans <strong>Signing &amp; Capabilities</strong>, et ajouter la clé <strong>NSMicrophoneUsageDescription</strong> dans l’onglet <strong>Info</strong>.</p>

<h2 id="structure-de-base">Structure de base</h2>

<p>Mon app de test comprend une seule vue, avec un bouton pour lancer/arrêter l’écoute du micro.
Les fonctionnalités d’accès au micro sont gérées dans un objet contrôleur <code class="language-plaintext highlighter-rouge">@Observable</code> utilisé comme <code class="language-plaintext highlighter-rouge">@State</code> dans la vue. Le contrôleur expose des fonctions <code class="language-plaintext highlighter-rouge">start()</code> et <code class="language-plaintext highlighter-rouge">stop()</code>, et une propriété observable <code class="language-plaintext highlighter-rouge">listening</code>, à <code class="language-plaintext highlighter-rouge">true</code> quand le micro est en cours d’écoute, <code class="language-plaintext highlighter-rouge">false</code> sinon.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">SpeechRecognitionApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">SpeechRecognitionRootView</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>    
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>      
        <span class="kt">HStack</span> <span class="p">{</span>    
            <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"Stop"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Listening"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="vérifier-la-permission-daccès-au-micro">Vérifier la permission d’accès au micro</h2>

<p>L’accès au micro peut être autorisé, refusé/restreint ou indéterminé :</p>

<ul>
  <li>
    <p>Le cas <em>autorisé</em> correspond au cas où l’utilisateur a explicitement autorisé l’accès.</p>
  </li>
  <li>
    <p>Le cas <em>refusé</em> correspond au cas où l’utilisateur a explicitement refusé l’accès.</p>
  </li>
  <li>
    <p>Le cas <em>restreint</em> correspond au cas où le système impose des restrictions, comme dans le cas d’un contrôle parental par exemple. Ici on considère ce cas équivalent à <em>refusé</em>.</p>
  </li>
  <li>
    <p>Le cas indéterminé correspond à la situation dans laquelle l’app n’a encore jamais demandé la permission.</p>
  </li>
</ul>

<p>Dans le contrôleur j’ajoute un un booléen optionnel qui reflètera l’état de l’autorisation d’accès au micro.
Une valeur <code class="language-plaintext highlighter-rouge">nil</code> correspond à un état indéterminé, <code class="language-plaintext highlighter-rouge">true</code> si autorisé, et <code class="language-plaintext highlighter-rouge">false</code> dans les autres cas.</p>

<p>Dans la vue j’affiche la valeur de l’autorisation.
Je crée aussi une propriété calculée <code class="language-plaintext highlighter-rouge">ready</code> qui permet d’ajuster l’interface dans le cas où la permission micro est refusée. En l’occurence on désactive le bouton <strong>Start</strong>.</p>

<p>Par la suite on demandera l’autorisation au moment où l’utilisateur•ice clic sur le bouton <strong>Start</strong>.
Il faut donc que celui-ci soit actif dans le cas où la permission est encore indéterminée.
De manière générale, quand la permission est encore indéterminée, il est plus engagent pour l’utilisateur•ice de présenter l’interface comme si elle était autorisée, et de ne la désactiver que lorsque la premission est explicitement refusée.
C’est pour cette raison que <code class="language-plaintext highlighter-rouge">ready</code> ne renvoit <code class="language-plaintext highlighter-rouge">false</code> que dans le cas où la premission est connue et refusée, et <code class="language-plaintext highlighter-rouge">true</code> dans tous les autres cas.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Microphone authorisation"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">microphoneAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>    
                <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                    <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
                    <span class="o">.</span><span class="nf">disabled</span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// ...</span>
                <span class="p">}</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>  
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>   
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">microphoneAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>    
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">microphoneAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ensuite dans le contrôleur je crée une propriété calculée pour encapsuler l’appel à la fonction système <code class="language-plaintext highlighter-rouge">AVCaptureDevice.authorizationStatus(for:)</code>, en indiquant qu’on souhaite accéder à l’audio.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">AVFoundation</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">microphoneAuthorisationStatus</span><span class="p">:</span> <span class="kt">AVAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">AVCaptureDevice</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">audio</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Je crée ensuite une fonction qui met à jour la propriété observable en fonction de la valeur brute de la permission.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">updateMicrophoneAuthorisationStatus</span><span class="p">()</span> <span class="p">{</span>   
        <span class="n">microphoneAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">microphoneAuthorisationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">microphoneAuthorized</code> pourrait être une propriété calculée, mais on n’aurait alors aucun moyen de communiquer les changements à la vue. L’observation nécessite une propriété stockée. C’est la mise à jour explicite de la propriété qui va déclencher la mise à jour de la vue. La contrepartie est qu’il faut penser à appeler <code class="language-plaintext highlighter-rouge">updateMicrophoneAuthorisationStatus()</code> aux moments opportuns.</p>

<p>Un moment opportun pour mettre à jour la valeur est au démarrage, j’ajoute donc un initialiseur dans le contrôleur qui fait une première mise à jour.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="nf">updateMicrophoneAuthorisationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ainsi quand l’app démarre l’affichage reflète la bonne valeur de l’autorisation.</p>

<h2 id="demander-la-permission-daccès-au-micro">Demander la permission d’accès au micro</h2>

<p>Il faut maintenant demander la permission d’accès au micro.</p>

<p>Je crée encore une fois une fonction pour encapsuler l’appel à la fonction système. La fonction est <code class="language-plaintext highlighter-rouge">AVCaptureDevice.requestAccess(for:)</code>, elle renvoie un booléen à <code class="language-plaintext highlighter-rouge">true</code> si autorisé, <code class="language-plaintext highlighter-rouge">false</code> sinon.
Ma méthode renvoie plutôt la valeur complète de l’autorisation, après avoir mis à jour la propriété.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">requestMicrophoneAuthorisation</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">AVAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="kt">AVCaptureDevice</span><span class="o">.</span><span class="nf">requestAccess</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">audio</span><span class="p">)</span>
        <span class="nf">updateMicrophoneAuthorisationStatus</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">microphoneAuthorisationStatus</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A noter que si l’app a déjà demandé la permission et que l’état d’autorisation est donc connu, <code class="language-plaintext highlighter-rouge">AVCaptureDevice.requestAccess(for:)</code> ne fait rien du tout.
Dans le cas contraire une boîte de dialogue demande à l’utilisateur s’il souhaite autoriser l’accès ou non.
On peut donc appeler la méthode <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorisation()</code> de manière systématique pour récupérer l’état de l’autorisation, la question étant préalablement posée à l’utilisateur si nécessaire.</p>

<p>Techniquement, demander la permission d’accès au micro et utiliser le micro sont deux choses différentes qui peuvent se produire à des moments différents. Et on pourrait tout à fait demander la permission au démarrage de l’application ou à l’arrivée sur l’écran. Cependant, demander la permission à l’utilisateur•ice lui donne l’impression qu’on va utiliser le micro immédiatement. Il est donc préférable de faire la demande au moment où on va réellement l’utiliser.</p>

<p>C’est pourquoi j’appelle la méthode <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorisation()</code> dans la fonction <code class="language-plaintext highlighter-rouge">start()</code> et non dans l’<code class="language-plaintext highlighter-rouge">init()</code>.
Comme <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorisation()</code> est <code class="language-plaintext highlighter-rouge">async</code>, je modifie <code class="language-plaintext highlighter-rouge">start()</code> pour l’être également, et je modifie l’action du bouton <strong>Start</strong> en conséquence.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">HStack</span> <span class="p">{</span>    
                <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                    <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="kt">Task</span> <span class="p">{</span> <span class="k">await</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}}</span>
                    <span class="o">.</span><span class="nf">disabled</span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// ...</span>
                <span class="p">}</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>  
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>    
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// check permission, ask if needed</span>
        <span class="k">let</span> <span class="nv">microphoneStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestMicrophoneAuthorisation</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">microphoneStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Microphone not authorized"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// next steps will follow here</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Une fois que l’app a demandé une première fois la permission, une entrée est créé dans les réglages de <strong>Confidentialité</strong> dans les <strong>Réglages système</strong>.
L’utilisateur•ice peut ensuite modifier à loisir la permission.</p>

<p>Une fois que l’entrée existe dans les réglages de <strong>Confidentialité</strong>, la boîte de dialogue d’autorisation ne s’affiche plus à l’utilisateur•ice.
C’est embêtant pour le développement, où on aimerait pouvoir revenir dans un état de permission indéterminée.</p>

<p>La commande suivante permet de supprimer l’entrée dans les réglages de <strong>Confidentialité</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset Microphone &lt;bundle.id&gt;
</code></pre></div></div>

<p>Attention si <code class="language-plaintext highlighter-rouge">&lt;bundle id&gt;</code> n’est pas précisé, la permission est réinitialisée pour <strong>toutes</strong> les apps du système.</p>

<h2 id="accéder-aux-données-audio">Accéder aux données audio</h2>

<p>Tout est enfin prêt pour recevoir les données audio !
Pour ça on utilise <code class="language-plaintext highlighter-rouge">AVAudioEngine</code>.</p>

<p>Je crée une nouvelle fonction <code class="language-plaintext highlighter-rouge">startAudio()</code> qui initialise une instance de <code class="language-plaintext highlighter-rouge">AVAudioEngine</code> dans et récupère le noeud d’entrée.
On configure ensuite un “tap” sur le noeud d’entrée qui nous permet de récupérer les données audio brute dans un buffer. La callback est appelée à de multiples reprises avec le flux de données.
Enfin on appelle <code class="language-plaintext highlighter-rouge">.prepare()</code> et <code class="language-plaintext highlighter-rouge">.start()</code> sur <code class="language-plaintext highlighter-rouge">audioEngine</code> pour lancer l’écoute.</p>

<p>Je crée aussi une fonction <code class="language-plaintext highlighter-rouge">stopAudio()</code> qui arrête l’<code class="language-plaintext highlighter-rouge">audioEngine</code> et supprime le tap.
On appelle <code class="language-plaintext highlighter-rouge">startAudio()</code> dans <code class="language-plaintext highlighter-rouge">start()</code> et <code class="language-plaintext highlighter-rouge">stopAudio()</code> dans <code class="language-plaintext highlighter-rouge">stop()</code>, et on peut mettre à jour le flag <code class="language-plaintext highlighter-rouge">listening</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">audioEngine</span><span class="p">:</span> <span class="kt">AVAudioEngine</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">inputNode</span><span class="p">:</span> <span class="kt">AVAudioInputNode</span><span class="o">!</span>

    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">try</span> <span class="nf">startAudio</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to start audio: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>   
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">startAudio</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="n">audioEngine</span> <span class="o">=</span> <span class="kt">AVAudioEngine</span><span class="p">()</span>
        <span class="n">inputNode</span> <span class="o">=</span> <span class="n">audioEngine</span><span class="o">.</span><span class="n">inputNode</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="c1">// receive audio data from buffer</span>
        <span class="p">}</span>
        
        <span class="n">audioEngine</span><span class="o">.</span><span class="nf">prepare</span><span class="p">()</span>
        <span class="k">try</span> <span class="n">audioEngine</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">stopAudio</span><span class="p">()</span> <span class="p">{</span>   
        <span class="n">audioEngine</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Et voilà, tout est prêt pour transmettre les données audio au module de reconnaissance vocale.</p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[J’ai une activité de vente en ligne de pièces de LEGO sur la plateforme BrickLink, et je développe une application mac en SwiftUI pour m’aider à gérer mes ventes.]]></summary></entry><entry><title type="html">Microphone access in a SwiftUI app</title><link href="/2025/02/28/swiftui-microphone_en.html" rel="alternate" type="text/html" title="Microphone access in a SwiftUI app" /><published>2025-02-28T04:02:15-06:00</published><updated>2025-02-28T04:02:15-06:00</updated><id>/2025/02/28/swiftui-microphone_en</id><content type="html" xml:base="/2025/02/28/swiftui-microphone_en.html"><![CDATA[<p>I run an online store for LEGO parts on the BrickLink platform, and I’m developing a macOS application in SwiftUI to help manage my sales.</p>

<p>For the picking assistance module, I envisioned a hands-free feature based on voice commands. To this end, I started experimenting with Apple’s speech recognition framework. However, first, we need to access the audio data from the microphone.</p>

<p>In this article, I’ll discuss how I implemented microphone access in a SwiftUI application.</p>

<h2 id="preparation">Preparation</h2>

<p>To allow the app to access the microphone, you need to check <strong>Audio Input</strong> in <strong>Signing &amp; Capabilities</strong> and add the <strong>NSMicrophoneUsageDescription</strong> key in the <strong>Info</strong> tab.</p>

<h2 id="basic-structure">Basic Structure</h2>

<p>My test app consists of a single view, with a button to start/stop listening to the microphone. The microphone access functionalities are managed in an <code class="language-plaintext highlighter-rouge">@Observable</code> controller used as <code class="language-plaintext highlighter-rouge">@State</code> in the view. The controller exposes <code class="language-plaintext highlighter-rouge">start()</code> and <code class="language-plaintext highlighter-rouge">stop()</code> functions, and an observable property <code class="language-plaintext highlighter-rouge">listening</code>, which is <code class="language-plaintext highlighter-rouge">true</code> when the microphone is listening and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">SpeechRecognitionApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">SpeechRecognitionRootView</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>    
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>      
        <span class="kt">HStack</span> <span class="p">{</span>    
            <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"Stop"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Listening"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="checking-microphone-access-permission">Checking Microphone Access Permission</h2>

<p>Microphone access can be authorized, denied/restricted, or undetermined:</p>

<ul>
  <li>The <em>authorized</em> case corresponds to when the user has explicitly granted access.</li>
  <li>The <em>denied</em> case corresponds to when the user has explicitly denied access.</li>
  <li>The <em>restricted</em> case corresponds to when the system imposes restrictions, such as in the case of parental controls. Here we consider this case equivalent to <em>denied</em>.</li>
  <li>The <em>undetermined</em> case corresponds to the situation where the app has never asked for permission.</li>
</ul>

<p>In the controller, I add an optional boolean that will reflect the microphone access authorization status. A <code class="language-plaintext highlighter-rouge">nil</code> value corresponds to an undetermined status, <code class="language-plaintext highlighter-rouge">true</code> if authorized, and <code class="language-plaintext highlighter-rouge">false</code> in other cases.</p>

<p>In the view, I display the authorization status. I also create a computed property <code class="language-plaintext highlighter-rouge">ready</code> that adjusts the interface in case microphone permission is denied, specifically disabling the <strong>Start</strong> button.</p>

<p>Subsequently, we will request permission when the user clicks the <strong>Start</strong> button. Therefore, this button should be active when the permission is still undetermined. Generally, when the permission is still undetermined, it is more engaging for the user to present the interface as if it were authorized, disabling it only when permission is explicitly denied. This is why <code class="language-plaintext highlighter-rouge">ready</code> only returns <code class="language-plaintext highlighter-rouge">false</code> when the permission is known and denied, and <code class="language-plaintext highlighter-rouge">true</code> in all other cases.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">GridRow</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Microphone authorization"</span><span class="p">)</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">microphoneAuthorized</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="n">authorized</span> <span class="p">?</span> <span class="s">"Granted"</span> <span class="p">:</span> <span class="s">"Denied"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">Text</span><span class="p">(</span><span class="s">"undetermined"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">HStack</span> <span class="p">{</span>    
                <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                    <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}</span>
                    <span class="o">.</span><span class="nf">disabled</span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// ...</span>
                <span class="p">}</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>  
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">ready</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>   
        <span class="k">if</span> <span class="k">let</span> <span class="nv">authorized</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">microphoneAuthorized</span><span class="p">,</span> <span class="n">authorized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>    
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">microphoneAuthorized</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, in the controller, I create a computed property to encapsulate the call to the system function <code class="language-plaintext highlighter-rouge">AVCaptureDevice.authorizationStatus(for:)</code>, indicating that we want to access audio.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">AVFoundation</span>

<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">microphoneAuthorizationStatus</span><span class="p">:</span> <span class="kt">AVAuthorizationStatus</span> <span class="p">{</span>
        <span class="kt">AVCaptureDevice</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">audio</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I then create a function that updates the observable property based on the raw value of the permission.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">updateMicrophoneAuthorizationStatus</span><span class="p">()</span> <span class="p">{</span>   
        <span class="n">microphoneAuthorized</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="n">microphoneAuthorizationStatus</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">authorized</span><span class="p">:</span> <span class="kc">true</span>
            <span class="k">default</span><span class="p">:</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">microphoneAuthorized</code> could be a computed property, but then we wouldn’t have a way to communicate changes to the view. Observability requires a stored property. It’s the explicit update of the property that triggers the view update. The trade-off is that we need to remember to call <code class="language-plaintext highlighter-rouge">updateMicrophoneAuthorizationStatus()</code> at the appropriate times.</p>

<p>An appropriate moment to update the value is at startup, so I add an initializer in the controller that performs an initial update.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="nf">updateMicrophoneAuthorizationStatus</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Thus, when the app starts, the view shows the correct authorization value.</p>

<h2 id="requesting-microphone-access-permission">Requesting Microphone Access Permission</h2>

<p>Now we need to request permission to access the microphone.</p>

<p>I create another function to encapsulate the call to the system function. The function is <code class="language-plaintext highlighter-rouge">AVCaptureDevice.requestAccess(for:)</code>, which returns a boolean <code class="language-plaintext highlighter-rouge">true</code> if authorized, <code class="language-plaintext highlighter-rouge">false</code> otherwise. My method returns the complete authorization status after updating the property.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">requestMicrophoneAuthorization</span><span class="p">()</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">AVAuthorizationStatus</span> <span class="p">{</span>
        <span class="k">await</span> <span class="kt">AVCaptureDevice</span><span class="o">.</span><span class="nf">requestAccess</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">audio</span><span class="p">)</span>
        <span class="nf">updateMicrophoneAuthorizationStatus</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">microphoneAuthorizationStatus</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that if the app has already requested permission and the authorization status is known, <code class="language-plaintext highlighter-rouge">AVCaptureDevice.requestAccess(for:)</code> does nothing at all. In the opposite case, a dialog box will ask the user whether they want to grant access or not. Therefore, we can systematically call the <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorization()</code> method to retrieve the authorization status, asking the question to the user if necessary.</p>

<p>Technically, requesting permission to access the microphone and using the microphone are two different things that can happen at different times. We could very well ask for permission at app startup or when arriving on the screen. However, asking the user for permission gives the impression that we will use the microphone immediately. It is therefore preferable to make the request at the moment we will actually use it.</p>

<p>That’s why I call the <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorization()</code> method in the <code class="language-plaintext highlighter-rouge">start()</code> function and not in the <code class="language-plaintext highlighter-rouge">init()</code>. Since <code class="language-plaintext highlighter-rouge">requestMicrophoneAuthorization()</code> is <code class="language-plaintext highlighter-rouge">async</code>, I also modify <code class="language-plaintext highlighter-rouge">start()</code> to be <code class="language-plaintext highlighter-rouge">async</code> and change the action of the <strong>Start</strong> button accordingly.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">SpeechRecognitionRootView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="k">var</span> <span class="nv">controller</span> <span class="o">=</span> <span class="kt">SpeechRecognitionController</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Grid</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="kt">HStack</span> <span class="p">{</span>    
                <span class="k">if</span> <span class="o">!</span><span class="n">controller</span><span class="o">.</span><span class="n">listening</span> <span class="p">{</span>
                    <span class="kt">Button</span><span class="p">(</span><span class="s">"Start"</span><span class="p">)</span> <span class="p">{</span> <span class="kt">Task</span> <span class="p">{</span> <span class="k">await</span> <span class="n">controller</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span> <span class="p">}}</span>
                    <span class="o">.</span><span class="nf">disabled</span><span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// ...</span>
                <span class="p">}</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>  
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">@Observable</span>
<span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>    
    <span class="c1">// ...</span>
    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// check permission, ask if needed</span>
        <span class="k">let</span> <span class="nv">microphoneStatus</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">requestMicrophoneAuthorization</span><span class="p">()</span>
        <span class="k">guard</span> <span class="n">microphoneStatus</span> <span class="o">==</span> <span class="o">.</span><span class="n">authorized</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Microphone not authorized"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// next steps will follow here</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once the app has requested permission for the first time, an entry is created in the <strong>Privacy</strong> settings in <strong>System Preferences</strong>. The user can then modify the permission at will.</p>

<p>Once the entry exists in the <strong>Privacy</strong> settings, the authorization dialog no longer appears to the user. This can be troublesome during development, as you might want to return to an undetermined permission state.</p>

<p>The following command allows you to delete the entry in the <strong>Privacy</strong> settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tccutil reset Microphone &lt;bundle.id&gt;
</code></pre></div></div>

<p>Be careful; if <code class="language-plaintext highlighter-rouge">&lt;bundle.id&gt;</code> is not specified, the permission is reset for <strong>all</strong> apps on the system.</p>

<h2 id="accessing-audio-data">Accessing Audio Data</h2>

<p>Everything is finally ready to receive audio data! We use <code class="language-plaintext highlighter-rouge">AVAudioEngine</code> for this.</p>

<p>I create a new function <code class="language-plaintext highlighter-rouge">startAudio()</code> that initializes an instance of <code class="language-plaintext highlighter-rouge">AVAudioEngine</code> and retrieves the input node. We then configure a “tap” on the input node that allows us to retrieve raw audio data in a buffer. The callback is called multiple times with the data stream. Finally, we call <code class="language-plaintext highlighter-rouge">.prepare()</code> and <code class="language-plaintext highlighter-rouge">.start()</code> on <code class="language-plaintext highlighter-rouge">audioEngine</code> to start listening.</p>

<p>I also create a <code class="language-plaintext highlighter-rouge">stopAudio()</code> function that stops the <code class="language-plaintext highlighter-rouge">audioEngine</code> and removes the tap. We call <code class="language-plaintext highlighter-rouge">startAudio()</code> in <code class="language-plaintext highlighter-rouge">start()</code> and <code class="language-plaintext highlighter-rouge">stopAudio()</code> in <code class="language-plaintext highlighter-rouge">stop()</code>, and we can update the <code class="language-plaintext highlighter-rouge">listening</code> flag.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SpeechRecognitionController</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">audioEngine</span><span class="p">:</span> <span class="kt">AVAudioEngine</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">inputNode</span><span class="p">:</span> <span class="kt">AVAudioInputNode</span><span class="o">!</span>

    <span class="kd">func</span> <span class="nf">start</span><span class="p">()</span> <span class="k">async</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">try</span> <span class="nf">startAudio</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Failed to start audio: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>   
        <span class="nf">stopAudio</span><span class="p">()</span>
        <span class="n">listening</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">startAudio</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="n">audioEngine</span> <span class="o">=</span> <span class="kt">AVAudioEngine</span><span class="p">()</span>
        <span class="n">inputNode</span> <span class="o">=</span> <span class="n">audioEngine</span><span class="o">.</span><span class="n">inputNode</span>
        
        <span class="k">let</span> <span class="nv">recordingFormat</span> <span class="o">=</span> <span class="n">inputNode</span><span class="o">.</span><span class="nf">outputFormat</span><span class="p">(</span><span class="nv">forBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">installTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">bufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nv">format</span><span class="p">:</span> <span class="n">recordingFormat</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">in</span>
            <span class="c1">// receive audio data from buffer</span>
        <span class="p">}</span>
        
        <span class="n">audioEngine</span><span class="o">.</span><span class="nf">prepare</span><span class="p">()</span>
        <span class="k">try</span> <span class="n">audioEngine</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">stopAudio</span><span class="p">()</span> <span class="p">{</span>   
        <span class="n">audioEngine</span><span class="o">.</span><span class="nf">stop</span><span class="p">()</span>
        <span class="n">inputNode</span><span class="o">.</span><span class="nf">removeTap</span><span class="p">(</span><span class="nv">onBus</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And there you go, everything is ready to transmit audio data to the speech recognition module.</p>]]></content><author><name>Alexandre Bintz</name></author><summary type="html"><![CDATA[I run an online store for LEGO parts on the BrickLink platform, and I’m developing a macOS application in SwiftUI to help manage my sales.]]></summary></entry></feed>